{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quanta.Guru This online document helps the absolute beginners to persue in the future direction in coding and Quantum Computing. The lesson starts with fundamental of qubits, quantum gates and quantum circuits and quantum algorithms. Qubit Qubit Single Qubit Gates Multiple Qubits Gates QUANTUM GATES Hadamard Gate U-gates Pauli Gates R-phi Gates CNOT gate QUANTUM CIRCUITS Single Qubit Circuit Two Qubit Circuit Three Qubit Circuit Multi Qubit Circuit ALGORITHMS Bell State Teleportation Quantum Parallelism Quantum Fourier Transform Grover's Algorithms -Shor's Algorithm Quantum Cryptography Quantum Cryptography","title":"Home"},{"location":"#quantaguru","text":"This online document helps the absolute beginners to persue in the future direction in coding and Quantum Computing. The lesson starts with fundamental of qubits, quantum gates and quantum circuits and quantum algorithms.","title":"Quanta.Guru"},{"location":"#qubit","text":"Qubit Single Qubit Gates Multiple Qubits Gates","title":"Qubit"},{"location":"#quantum-gates","text":"Hadamard Gate U-gates Pauli Gates R-phi Gates CNOT gate","title":"QUANTUM GATES"},{"location":"#quantum-circuits","text":"Single Qubit Circuit Two Qubit Circuit Three Qubit Circuit Multi Qubit Circuit","title":"QUANTUM CIRCUITS"},{"location":"#algorithms","text":"Bell State Teleportation Quantum Parallelism Quantum Fourier Transform Grover's Algorithms -Shor's Algorithm","title":"ALGORITHMS"},{"location":"#quantum-cryptography","text":"Quantum Cryptography","title":"Quantum Cryptography"},{"location":"GettingStarted/anaconda/","text":"Installing Python To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python. Note- Linux: For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook Note - Cloud For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Guide to starting Python"},{"location":"GettingStarted/anaconda/#installing-python","text":"To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python.","title":"Installing Python"},{"location":"GettingStarted/anaconda/#note-linux","text":"For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook","title":"Note- Linux:"},{"location":"GettingStarted/anaconda/#note-cloud","text":"For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Note - Cloud"},{"location":"GettingStarted/env/","text":"Python Environment Basics To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = /Users/username/anaconda/bin: $PATH or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup Environments Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate Saving and loading environments A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml . Listing environments If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root . Removing environments If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ). Using environments One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican . Sharing environments When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda. More to learn To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"Setting up Python Environment"},{"location":"GettingStarted/env/#python-environment","text":"","title":"Python Environment"},{"location":"GettingStarted/env/#basics","text":"To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = /Users/username/anaconda/bin: $PATH or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup","title":"Basics"},{"location":"GettingStarted/env/#environments","text":"Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate","title":"Environments"},{"location":"GettingStarted/env/#saving-and-loading-environments","text":"A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml .","title":"Saving and loading environments"},{"location":"GettingStarted/env/#listing-environments","text":"If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root .","title":"Listing environments"},{"location":"GettingStarted/env/#removing-environments","text":"If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ).","title":"Removing environments"},{"location":"GettingStarted/env/#using-environments","text":"One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican .","title":"Using environments"},{"location":"GettingStarted/env/#sharing-environments","text":"When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda.","title":"Sharing environments"},{"location":"GettingStarted/env/#more-to-learn","text":"To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"More to learn"},{"location":"GettingStarted/git/","text":"How to git Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m First commit Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to Git"},{"location":"GettingStarted/git/#how-to-git","text":"Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m First commit Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to git"},{"location":"GettingStarted/jupyter/","text":"Installing Jupyter Notebook By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"GettingStarted/jupyter/#installing-jupyter-notebook","text":"By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"algorithms/qft/qft/","text":"Quantum Fourier Transform Bell state is constructed with application of $\\textbf{Hadamard}$ and $\\textbf{CNOT}$ gates in two qubit system. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit,ClassicalRegister,QuantumRegister from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * QFT is defined as $$ QFT:|x = \\frac{1}{\\sqrt{N}}\\sum_{k=0}^{N-1} \\omega_{x}^{k}|k $$ where \\( \\omega_{x}^{k} \\) is \\( N^{th} (N = 2^{n} \\) ) root of unity: \\( e^{\\frac{2\\pi i}{2^{n}}} \\). $$ QFT: F_{N} = \\frac{1}{\\sqrt{N}} \\left( \\begin{array}{cccccc} 1 1 1 1 \\cdots 1 \\\\ 1 \\omega_{n} \\omega_{n}^{2} \\omega_{n}^{3} \\cdots \\omega_{n} ^{N-1}\\\\ 1 \\omega_{n}^{2} \\omega_{n}^{4} \\omega_{n}^{6} \\cdots \\omega_{n} ^{2(N-1)}\\\\ 1 \\omega_{n}^{3} \\omega_{n}^{6} \\omega_{n}^{9} \\cdots \\omega_{n} ^{3(N-1)}\\\\ \\vdots \\vdots \\vdots \\vdots \\dots \\vdots \\\\ 1 \\omega_{n}^{(N-1)} \\omega_{n}^{2(N-1)} \\omega_{n}^{3(N-1)} \\cdots \\omega_{n} ^{(N-1((N-1)}\\\\ \\end{array}\\right )$$ QFT ( 1 qubit) For single qubit circuit ( \\( n = 1, N = 2^{1} = 2)\\) $$\\omega_n = e^{\\frac{2\\pi i}{2^{n}}} = -1$$. $$QFT_1 = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 1 \\\\ 1 -1\\\\ \\end{array}\\right)$$ It is very simple, QFT in single qubit id just a Hadamate operation. QFT (2 qubits) For two qubit circuit, ( \\( n =2, N = 2^{2} = 4)\\) $$ \\omega_{n} = e^{\\frac{2\\pi i}{2^{n}}} = i$$ $$QFT_2 = \\frac{1}{{2}}\\left( \\begin{array}{cc} 1 1 1 1\\\\ 1 i -1 -i\\\\ 1 -1 1 -1\\\\ 1 -i -1 i\\\\ \\end{array} \\right) $$ Our task is to represent this matrix in terms of fundamental gate metrix. Circuit def qft2 (): qc = QuantumCircuit( 2 , 2 ) qc . h( 1 ) qc . barrier() qc . cu1(np . pi / 2 , 0 , 1 ) qc . barrier() qc . h( 0 ) qc . barrier() qc . swap( 0 , 1 ) return qc qc = qft2() drawCircuit_2q(qc) Phase def getPhaseSeq (): phaseDic = [] qc = QuantumCircuit( 2 , 2 ) qc0 = qc . copy() qc . h( 1 ) qc1 = qc . copy() qc . cu1(np . pi / 2 , 0 , 1 ) qc2 = qc . copy() qc . h( 0 ) qc3 = qc . copy() qc . swap( 0 , 1 ) qc4 = qc . copy() for iqc in [qc0,qc1,qc2,qc3,qc4]: phaseDic . append(getPhase(iqc)) return phaseDic drawPhase(getPhaseSeq()) State vector as tensor product Since this circuit consists of pure superposition brought up by hadamard gate, it is possible to obtain final state vector by taking direct product of single qubit states. Results from operation of H gate on single qubit can be multiplied with direct product operation to get final state. $$ \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0 \\rangle + | 1\\rangle) = \\frac{1}{2}(|00 \\rangle + |01 \\rangle + |10 \\rangle + |11 \\rangle $$ i.e., $$\\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array} \\right) \\otimes \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array} \\right) = \\frac{1}{2} \\left( \\begin{array}{cc} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{array} \\right) $$ Where \\( |00 \\rangle , |01 \\rangle , |10 \\rangle \\) and \\( |11 \\rangle \\) are basis states for two qubit system. Matrix Element How to realize it the quantum circuit? $$ I = \\left( \\begin{array}{cc} 1 0 \\\\ 0 1 \\end{array} \\right) ;H = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 0 \\\\ 0 1 \\end{array} \\right) ;$$ $$ C_{u1} =\\left( \\begin{array}{cc} 1 0 0 0\\\\ 0 1 0 0\\\\ 0 0 1 0\\\\ 0 0 0 i \\end{array} \\right) ; SWAP =\\left( \\begin{array}{cc} 1 0 0 0\\\\ 0 0 1 0\\\\ 0 1 0 0\\\\ 0 0 0 1 \\end{array} \\right) $$ At first barrier: \\( U_1 = I \\otimes H \\) At second barrier: \\( U_2 = C _{u1} \\times (I \\otimes H) \\) At third barrier: \\( U_3 = (H \\otimes I) \\times C _{u1} \\times (I \\otimes H) \\) At fourth barrier: \\( U_4 = SWAP \\times (H \\otimes I) \\times C _{u1} \\times (I \\otimes H) \\) Implementing Numpy I = np . eye( 2 , 2 ) H = 1 / np . sqrt( 2 ) * np . array([[ 1 , 1 ],[ 1 , - 1 ]]) H_kron_I = np . kron(H,I) CU1 = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 0. + 1. j]]) I_kron_H = np . kron(I,H) SWAP = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 0 , 1 ]]) U = np . dot(H_kron_I,np . dot(CU1,np . dot(I_kron_H,SWAP))) U array([[ 0.5+0.j , 0.5+0.j , 0.5+0.j , 0.5+0.j ], [ 0.5+0.j , 0. +0.5j, -0.5+0.j , 0. -0.5j], [ 0.5+0.j , -0.5+0.j , 0.5+0.j , -0.5+0.j ], [ 0.5+0.j , 0. -0.5j, -0.5+0.j , 0. +0.5j]]) ket = np . array([ 1 , 0 , 0 , 0 ]) np . dot(U,ket) array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j]) qc = qft2() plotMatrix(qc) QFT (3 qubits) Circuit Diagram def qft3 (): n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) qc . h(q[ 2 ]) qc . barrier() qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc . barrier() qc . h(q[ 1 ]) qc . barrier() qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc . barrier() qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . barrier() qc . h(q[ 0 ]) qc . barrier() qc . swap(q[ 0 ], q[ 2 ]) return q,c,qc q,c,qc = qft3() qc . barrier() qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) State vector Intermediate Ket and Phases def getPhaseSeq (): phaseDic = [] QC = [] n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) qc0 = qc . copy() qc . h(q[ 2 ]) qc1 = qc . copy() qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc2 = qc . copy() qc . h(q[ 1 ]) qc3 = qc . copy() qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc4 = qc . copy() qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc5 = qc . copy() qc . h(q[ 0 ]) qc6 = qc . copy() qc . swap(q[ 0 ], q[ 2 ]) qc7 = qc . copy() QC = [qc0,qc1,qc2,qc3,qc4,qc5,qc6,qc7] for iqc in QC: phaseDic . append(getPhase(iqc)) return QC, phaseDic drawPhase(phaseDic) Matrix Element q,c,qc = qft3() plotMatrix(qc)","title":"Quantum Fourier Transform"},{"location":"algorithms/qft/qft/#quantum-fourier-transform","text":"Bell state is constructed with application of $\\textbf{Hadamard}$ and $\\textbf{CNOT}$ gates in two qubit system. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit,ClassicalRegister,QuantumRegister from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * QFT is defined as $$ QFT:|x = \\frac{1}{\\sqrt{N}}\\sum_{k=0}^{N-1} \\omega_{x}^{k}|k $$ where \\( \\omega_{x}^{k} \\) is \\( N^{th} (N = 2^{n} \\) ) root of unity: \\( e^{\\frac{2\\pi i}{2^{n}}} \\). $$ QFT: F_{N} = \\frac{1}{\\sqrt{N}} \\left( \\begin{array}{cccccc} 1 1 1 1 \\cdots 1 \\\\ 1 \\omega_{n} \\omega_{n}^{2} \\omega_{n}^{3} \\cdots \\omega_{n} ^{N-1}\\\\ 1 \\omega_{n}^{2} \\omega_{n}^{4} \\omega_{n}^{6} \\cdots \\omega_{n} ^{2(N-1)}\\\\ 1 \\omega_{n}^{3} \\omega_{n}^{6} \\omega_{n}^{9} \\cdots \\omega_{n} ^{3(N-1)}\\\\ \\vdots \\vdots \\vdots \\vdots \\dots \\vdots \\\\ 1 \\omega_{n}^{(N-1)} \\omega_{n}^{2(N-1)} \\omega_{n}^{3(N-1)} \\cdots \\omega_{n} ^{(N-1((N-1)}\\\\ \\end{array}\\right )$$","title":"Quantum Fourier Transform"},{"location":"algorithms/qft/qft/#qft-1-qubit","text":"For single qubit circuit ( \\( n = 1, N = 2^{1} = 2)\\) $$\\omega_n = e^{\\frac{2\\pi i}{2^{n}}} = -1$$. $$QFT_1 = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 1 \\\\ 1 -1\\\\ \\end{array}\\right)$$ It is very simple, QFT in single qubit id just a Hadamate operation.","title":"QFT ( 1 qubit)"},{"location":"algorithms/qft/qft/#qft-2-qubits","text":"For two qubit circuit, ( \\( n =2, N = 2^{2} = 4)\\) $$ \\omega_{n} = e^{\\frac{2\\pi i}{2^{n}}} = i$$ $$QFT_2 = \\frac{1}{{2}}\\left( \\begin{array}{cc} 1 1 1 1\\\\ 1 i -1 -i\\\\ 1 -1 1 -1\\\\ 1 -i -1 i\\\\ \\end{array} \\right) $$ Our task is to represent this matrix in terms of fundamental gate metrix. Circuit def qft2 (): qc = QuantumCircuit( 2 , 2 ) qc . h( 1 ) qc . barrier() qc . cu1(np . pi / 2 , 0 , 1 ) qc . barrier() qc . h( 0 ) qc . barrier() qc . swap( 0 , 1 ) return qc qc = qft2() drawCircuit_2q(qc) Phase def getPhaseSeq (): phaseDic = [] qc = QuantumCircuit( 2 , 2 ) qc0 = qc . copy() qc . h( 1 ) qc1 = qc . copy() qc . cu1(np . pi / 2 , 0 , 1 ) qc2 = qc . copy() qc . h( 0 ) qc3 = qc . copy() qc . swap( 0 , 1 ) qc4 = qc . copy() for iqc in [qc0,qc1,qc2,qc3,qc4]: phaseDic . append(getPhase(iqc)) return phaseDic drawPhase(getPhaseSeq()) State vector as tensor product Since this circuit consists of pure superposition brought up by hadamard gate, it is possible to obtain final state vector by taking direct product of single qubit states. Results from operation of H gate on single qubit can be multiplied with direct product operation to get final state. $$ \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0 \\rangle + | 1\\rangle) = \\frac{1}{2}(|00 \\rangle + |01 \\rangle + |10 \\rangle + |11 \\rangle $$ i.e., $$\\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array} \\right) \\otimes \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array} \\right) = \\frac{1}{2} \\left( \\begin{array}{cc} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{array} \\right) $$ Where \\( |00 \\rangle , |01 \\rangle , |10 \\rangle \\) and \\( |11 \\rangle \\) are basis states for two qubit system. Matrix Element How to realize it the quantum circuit? $$ I = \\left( \\begin{array}{cc} 1 0 \\\\ 0 1 \\end{array} \\right) ;H = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 0 \\\\ 0 1 \\end{array} \\right) ;$$ $$ C_{u1} =\\left( \\begin{array}{cc} 1 0 0 0\\\\ 0 1 0 0\\\\ 0 0 1 0\\\\ 0 0 0 i \\end{array} \\right) ; SWAP =\\left( \\begin{array}{cc} 1 0 0 0\\\\ 0 0 1 0\\\\ 0 1 0 0\\\\ 0 0 0 1 \\end{array} \\right) $$ At first barrier: \\( U_1 = I \\otimes H \\) At second barrier: \\( U_2 = C _{u1} \\times (I \\otimes H) \\) At third barrier: \\( U_3 = (H \\otimes I) \\times C _{u1} \\times (I \\otimes H) \\) At fourth barrier: \\( U_4 = SWAP \\times (H \\otimes I) \\times C _{u1} \\times (I \\otimes H) \\) Implementing Numpy I = np . eye( 2 , 2 ) H = 1 / np . sqrt( 2 ) * np . array([[ 1 , 1 ],[ 1 , - 1 ]]) H_kron_I = np . kron(H,I) CU1 = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 0. + 1. j]]) I_kron_H = np . kron(I,H) SWAP = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 0 , 1 ]]) U = np . dot(H_kron_I,np . dot(CU1,np . dot(I_kron_H,SWAP))) U array([[ 0.5+0.j , 0.5+0.j , 0.5+0.j , 0.5+0.j ], [ 0.5+0.j , 0. +0.5j, -0.5+0.j , 0. -0.5j], [ 0.5+0.j , -0.5+0.j , 0.5+0.j , -0.5+0.j ], [ 0.5+0.j , 0. -0.5j, -0.5+0.j , 0. +0.5j]]) ket = np . array([ 1 , 0 , 0 , 0 ]) np . dot(U,ket) array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j]) qc = qft2() plotMatrix(qc)","title":"QFT (2 qubits)"},{"location":"algorithms/qft/qft/#qft-3-qubits","text":"Circuit Diagram def qft3 (): n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) qc . h(q[ 2 ]) qc . barrier() qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc . barrier() qc . h(q[ 1 ]) qc . barrier() qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc . barrier() qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . barrier() qc . h(q[ 0 ]) qc . barrier() qc . swap(q[ 0 ], q[ 2 ]) return q,c,qc q,c,qc = qft3() qc . barrier() qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) State vector Intermediate Ket and Phases def getPhaseSeq (): phaseDic = [] QC = [] n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) qc0 = qc . copy() qc . h(q[ 2 ]) qc1 = qc . copy() qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc2 = qc . copy() qc . h(q[ 1 ]) qc3 = qc . copy() qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc4 = qc . copy() qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc5 = qc . copy() qc . h(q[ 0 ]) qc6 = qc . copy() qc . swap(q[ 0 ], q[ 2 ]) qc7 = qc . copy() QC = [qc0,qc1,qc2,qc3,qc4,qc5,qc6,qc7] for iqc in QC: phaseDic . append(getPhase(iqc)) return QC, phaseDic drawPhase(phaseDic) Matrix Element q,c,qc = qft3() plotMatrix(qc)","title":"QFT (3 qubits)"},{"location":"circuits/Multi-qubit-circuits/Multi-qubit-circuits/","text":"Muti Qubits Circuits % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy from numpy import pi Controlled Phase Rotation qc = QuantumCircuit( 2 ) qc . cu1(np . pi / 2 , 0 , 1 ) qc . draw(output = mpl ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+1.j]]) U operator and control phase gate $$ (I \\otimes I \\otimes U_3) \\times (I \\otimes CU_1 ) \\times (I \\otimes U_3 \\otimes I) \\times (CU_1 \\otimes I) \\times (U_3 \\otimes I \\otimes I)$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . cu1(pi / 2 ,q[ 0 ], q[ 1 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) qc . cu1(pi / 2 ,q[ 1 ], q[ 2 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.354+0.j , -0. -0.354j, 0. -0.354j, -0.354+0.j , 0. -0.354j, -0.354+0.j , -0.354+0.j , 0. +0.354j], [ 0. +0.354j, -0.354+0.j , 0. +0.354j, -0.354+0.j , 0.354+0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j], [ 0. +0.354j, 0.354+0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j], [-0.354+0.j , 0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.354j], [ 0. +0.354j, 0.354-0.j , 0.354-0.j , -0. -0.354j, -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. -0.354j, 0.354+0.j , -0. -0.354j, 0.354-0.j ], [-0.354+0.j , 0. +0.354j, -0. -0.354j, -0.354+0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j ], [-0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j ]]) All Gates together in 4-qubit circut q = QuantumRegister( 4 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . cu1(pi / 2 ,q[ 0 ], q[ 1 ]) qc . u2(pi / 2 ,pi / 2 ,q[ 1 ]) qc . u1(pi / 2 ,q[ 2 ]) qc . x(q[ 0 ]) qc . ccx(q[ 1 ],q[ 2 ],q[ 3 ]) qc . y(q[ 1 ]) qc . z(q[ 2 ]) qc . cx(q[ 2 ],q[ 3 ]) qc . z(q[ 3 ]) qc . h(q[ 3 ]) qc . s(q[ 0 ]) qc . cu1(pi / 2 ,q[ 1 ], q[ 2 ]) qc . swap(q[ 0 ],q[ 2 ]) qc . cswap(q[ 0 ],q[ 1 ],q[ 3 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.354j], [-0.354+0.j , 0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j], [ 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.354j, -0.354+0.j , 0.354-0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, -0. -0.354j, -0.354+0.j ], [-0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, -0. -0.354j, -0.354+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j ], [ 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j], [-0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j], [ 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, -0. -0.354j, -0.354+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ]])","title":"Multi qubit Circuit"},{"location":"circuits/Multi-qubit-circuits/Multi-qubit-circuits/#muti-qubits-circuits","text":"% matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy from numpy import pi","title":"Muti Qubits Circuits"},{"location":"circuits/Multi-qubit-circuits/Multi-qubit-circuits/#controlled-phase-rotation","text":"qc = QuantumCircuit( 2 ) qc . cu1(np . pi / 2 , 0 , 1 ) qc . draw(output = mpl ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+1.j]])","title":"Controlled Phase Rotation"},{"location":"circuits/Multi-qubit-circuits/Multi-qubit-circuits/#u-operator-and-control-phase-gate","text":"$$ (I \\otimes I \\otimes U_3) \\times (I \\otimes CU_1 ) \\times (I \\otimes U_3 \\otimes I) \\times (CU_1 \\otimes I) \\times (U_3 \\otimes I \\otimes I)$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . cu1(pi / 2 ,q[ 0 ], q[ 1 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) qc . cu1(pi / 2 ,q[ 1 ], q[ 2 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.354+0.j , -0. -0.354j, 0. -0.354j, -0.354+0.j , 0. -0.354j, -0.354+0.j , -0.354+0.j , 0. +0.354j], [ 0. +0.354j, -0.354+0.j , 0. +0.354j, -0.354+0.j , 0.354+0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j], [ 0. +0.354j, 0.354+0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j], [-0.354+0.j , 0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.354j], [ 0. +0.354j, 0.354-0.j , 0.354-0.j , -0. -0.354j, -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. -0.354j, 0.354+0.j , -0. -0.354j, 0.354-0.j ], [-0.354+0.j , 0. +0.354j, -0. -0.354j, -0.354+0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j ], [-0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j ]])","title":"U operator and control phase gate"},{"location":"circuits/Multi-qubit-circuits/Multi-qubit-circuits/#all-gates-together-in-4-qubit-circut","text":"q = QuantumRegister( 4 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . cu1(pi / 2 ,q[ 0 ], q[ 1 ]) qc . u2(pi / 2 ,pi / 2 ,q[ 1 ]) qc . u1(pi / 2 ,q[ 2 ]) qc . x(q[ 0 ]) qc . ccx(q[ 1 ],q[ 2 ],q[ 3 ]) qc . y(q[ 1 ]) qc . z(q[ 2 ]) qc . cx(q[ 2 ],q[ 3 ]) qc . z(q[ 3 ]) qc . h(q[ 3 ]) qc . s(q[ 0 ]) qc . cu1(pi / 2 ,q[ 1 ], q[ 2 ]) qc . swap(q[ 0 ],q[ 2 ]) qc . cswap(q[ 0 ],q[ 1 ],q[ 3 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.354j], [-0.354+0.j , 0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j], [ 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.354j, -0.354+0.j , 0.354-0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, -0. -0.354j, -0.354+0.j ], [-0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, -0. -0.354j, -0.354+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j ], [ 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j], [-0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , -0. -0.354j, -0.354+0.j , -0. -0.354j], [ 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.354-0.j , -0. -0.354j, -0. -0.354j, -0.354+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ]])","title":"All Gates together in 4-qubit circut"},{"location":"circuits/One-qubit-circuit/One-qubit-circuit/","text":"Single Qubit Circuits % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy Single qubit circuit: Base states : |0 , |1 qc = QuantumCircuit( 1 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , -0. -0.707j], [ 0. +0.707j, -0.707+0.j ]]) Gates in series qc = QuantumCircuit( 1 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[1.+0.j, 0.+0.j], [0.+0.j, 1.+0.j]])","title":"One qubit Circuit"},{"location":"circuits/One-qubit-circuit/One-qubit-circuit/#single-qubit-circuits","text":"% matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy","title":"Single Qubit Circuits"},{"location":"circuits/One-qubit-circuit/One-qubit-circuit/#single-qubit-circuit","text":"Base states : |0 , |1 qc = QuantumCircuit( 1 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , -0. -0.707j], [ 0. +0.707j, -0.707+0.j ]])","title":"Single qubit circuit:"},{"location":"circuits/One-qubit-circuit/One-qubit-circuit/#gates-in-series","text":"qc = QuantumCircuit( 1 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[1.+0.j, 0.+0.j], [0.+0.j, 1.+0.j]])","title":"Gates in series"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/","text":"Three Qubit Circuits % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy from numpy import pi Three qubit circuit Base states: |000 ,|001 ,|010 ,|011 ,|100 ,|110 ,|101 ,|111 Gate on First Qubit \\( I \\otimes I \\otimes U \\) q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j ]]) Gate on Second Qubit \\( I \\otimes U \\otimes I \\) q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j ]]) Gate on Third Qubit $$U \\otimes I \\otimes I$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j, 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j], [ 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j ]]) Gates on first two qubits $$I \\otimes U \\otimes U$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.5+0.j , -0. -0.5j, -0. -0.5j, -0.5+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.5j, -0.5+0.j , 0.5-0.j , 0. +0.5j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.5j, 0.5-0.j , -0.5+0.j , 0. +0.5j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [-0.5+0.j , -0. -0.5j, -0. -0.5j, 0.5-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.5+0.j , -0. -0.5j, -0. -0.5j, -0.5+0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.5j, -0.5+0.j , 0.5-0.j , 0. +0.5j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.5j, 0.5-0.j , -0.5+0.j , 0. +0.5j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.5+0.j , -0. -0.5j, -0. -0.5j, 0.5-0.j ]]) Gate on all 3 qubits $$U \\otimes U \\otimes U$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.354+0.j , -0. -0.354j, -0. -0.354j, -0.354+0.j , -0. -0.354j, -0.354+0.j , -0.354+0.j , 0. +0.354j], [ 0. +0.354j, -0.354+0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, -0. -0.354j, 0.354-0.j ], [ 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , -0. -0.354j, -0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , -0.354+0.j , -0. -0.354j], [ 0. +0.354j, 0.354-0.j , 0.354-0.j , -0. -0.354j, -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , -0. -0.354j, 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , -0.354+0.j , -0. -0.354j], [-0.354+0.j , 0. +0.354j, -0. -0.354j, -0.354+0.j , -0. -0.354j, -0.354+0.j , 0.354-0.j , -0. -0.354j], [-0. -0.354j, 0.354-0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, 0. +0.354j, -0.354+0.j ]]) Gate on all qubits $$(U \\times U) \\otimes (U \\times U) \\otimes (U \\times U)$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 4 ,pi / 4 ,pi / 4 ,q[ 1 ]) qc . u3( 3 * pi / 4 , 3 * pi / 4 , 3 * pi / 4 ,q[ 1 ]) qc . u3(pi / 6 ,pi / 6 ,pi / 6 ,q[ 2 ]) qc . u3( 5 * pi / 6 , 5 * pi / 6 , 5 * pi / 6 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.354+0.j , 0. +0.j , 0.25 +0.25j , 0. +0.j , 0.53 +0.306j, 0. +0.j , 0.158+0.592j, 0. +0.j ], [ 0. +0.j , 0.354+0.j , 0. +0.j , 0.25 +0.25j , 0. +0.j , 0.53 +0.306j, 0. +0.j , 0.158+0.592j], [-0.25 +0.25j , 0. +0.j , 0.354-0.j , 0. +0.j , -0.592+0.158j, 0. +0.j , 0.53 +0.306j, 0. +0.j ], [ 0. +0.j , -0.25 +0.25j , 0. +0.j , 0.354-0.j , 0. +0.j , -0.592+0.158j, 0. +0.j , 0.53 +0.306j], [-0.53 +0.306j, 0. +0.j , -0.592-0.158j, 0. +0.j , 0.354-0.j , 0. +0.j , 0.25 +0.25j , 0. +0.j ], [ 0. +0.j , -0.53 +0.306j, 0. +0.j , -0.592-0.158j, 0. +0.j , 0.354-0.j , 0. +0.j , 0.25 +0.25j ], [ 0.158-0.592j, 0. +0.j , -0.53 +0.306j, 0. +0.j , -0.25 +0.25j , 0. +0.j , 0.354-0.j , 0. +0.j ], [ 0. +0.j , 0.158-0.592j, 0. +0.j , -0.53 +0.306j, 0. +0.j , -0.25 +0.25j , 0. +0.j , 0.354-0.j ]])","title":"Three qubit Circuit"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#three-qubit-circuits","text":"% matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy from numpy import pi","title":"Three Qubit Circuits"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#three-qubit-circuit","text":"Base states: |000 ,|001 ,|010 ,|011 ,|100 ,|110 ,|101 ,|111","title":"Three qubit circuit"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#gate-on-first-qubit","text":"\\( I \\otimes I \\otimes U \\) q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j ]])","title":"Gate on First Qubit"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#gate-on-second-qubit","text":"\\( I \\otimes U \\otimes I \\) q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j ]])","title":"Gate on Second Qubit"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#gate-on-third-qubit","text":"$$U \\otimes I \\otimes I$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j, 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j, 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0. -0.707j], [ 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.707j, 0. +0.j , 0. +0.j , 0. +0.j , -0.707+0.j ]])","title":"Gate on Third Qubit"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#gates-on-first-two-qubits","text":"$$I \\otimes U \\otimes U$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.5+0.j , -0. -0.5j, -0. -0.5j, -0.5+0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.5j, -0.5+0.j , 0.5-0.j , 0. +0.5j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.5j, 0.5-0.j , -0.5+0.j , 0. +0.5j, 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [-0.5+0.j , -0. -0.5j, -0. -0.5j, 0.5-0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0.5+0.j , -0. -0.5j, -0. -0.5j, -0.5+0.j ], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.5j, -0.5+0.j , 0.5-0.j , 0. +0.5j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.5j, 0.5-0.j , -0.5+0.j , 0. +0.5j], [ 0. +0.j , 0. +0.j , 0. +0.j , 0. +0.j , -0.5+0.j , -0. -0.5j, -0. -0.5j, 0.5-0.j ]])","title":"Gates on first two qubits"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#gate-on-all-3-qubits","text":"$$U \\otimes U \\otimes U$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 1 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.354+0.j , -0. -0.354j, -0. -0.354j, -0.354+0.j , -0. -0.354j, -0.354+0.j , -0.354+0.j , 0. +0.354j], [ 0. +0.354j, -0.354+0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, -0. -0.354j, 0.354-0.j ], [ 0. +0.354j, 0.354-0.j , -0.354+0.j , 0. +0.354j, 0.354-0.j , -0. -0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , -0. -0.354j, -0. -0.354j, 0.354-0.j , 0. +0.354j, -0.354+0.j , -0.354+0.j , -0. -0.354j], [ 0. +0.354j, 0.354-0.j , 0.354-0.j , -0. -0.354j, -0.354+0.j , 0. +0.354j, 0. +0.354j, 0.354-0.j ], [-0.354+0.j , -0. -0.354j, 0. +0.354j, -0.354+0.j , -0. -0.354j, 0.354-0.j , -0.354+0.j , -0. -0.354j], [-0.354+0.j , 0. +0.354j, -0. -0.354j, -0.354+0.j , -0. -0.354j, -0.354+0.j , 0.354-0.j , -0. -0.354j], [-0. -0.354j, 0.354-0.j , 0.354-0.j , 0. +0.354j, 0.354-0.j , 0. +0.354j, 0. +0.354j, -0.354+0.j ]])","title":"Gate on all 3 qubits"},{"location":"circuits/Three-qubit-circuit/Three-qubit-circuit/#gate-on-all-qubits","text":"$$(U \\times U) \\otimes (U \\times U) \\otimes (U \\times U)$$ q = QuantumRegister( 3 ) qc = QuantumCircuit(q) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 2 ,pi / 2 ,pi / 2 ,q[ 0 ]) qc . u3(pi / 4 ,pi / 4 ,pi / 4 ,q[ 1 ]) qc . u3( 3 * pi / 4 , 3 * pi / 4 , 3 * pi / 4 ,q[ 1 ]) qc . u3(pi / 6 ,pi / 6 ,pi / 6 ,q[ 2 ]) qc . u3( 5 * pi / 6 , 5 * pi / 6 , 5 * pi / 6 ,q[ 2 ]) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.354+0.j , 0. +0.j , 0.25 +0.25j , 0. +0.j , 0.53 +0.306j, 0. +0.j , 0.158+0.592j, 0. +0.j ], [ 0. +0.j , 0.354+0.j , 0. +0.j , 0.25 +0.25j , 0. +0.j , 0.53 +0.306j, 0. +0.j , 0.158+0.592j], [-0.25 +0.25j , 0. +0.j , 0.354-0.j , 0. +0.j , -0.592+0.158j, 0. +0.j , 0.53 +0.306j, 0. +0.j ], [ 0. +0.j , -0.25 +0.25j , 0. +0.j , 0.354-0.j , 0. +0.j , -0.592+0.158j, 0. +0.j , 0.53 +0.306j], [-0.53 +0.306j, 0. +0.j , -0.592-0.158j, 0. +0.j , 0.354-0.j , 0. +0.j , 0.25 +0.25j , 0. +0.j ], [ 0. +0.j , -0.53 +0.306j, 0. +0.j , -0.592-0.158j, 0. +0.j , 0.354-0.j , 0. +0.j , 0.25 +0.25j ], [ 0.158-0.592j, 0. +0.j , -0.53 +0.306j, 0. +0.j , -0.25 +0.25j , 0. +0.j , 0.354-0.j , 0. +0.j ], [ 0. +0.j , 0.158-0.592j, 0. +0.j , -0.53 +0.306j, 0. +0.j , -0.25 +0.25j , 0. +0.j , 0.354-0.j ]])","title":"Gate on all qubits"},{"location":"circuits/Two-qubit-circuit/Two-qubit-circuit/","text":"Two Qubit Circuits % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy Double Qubit Circuit Base states: |00 , |01 , |10 ,|11 Gate on First Qubit \\( I \\otimes U \\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j ], [ 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j], [ 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j ]]) Gate on Second Qubit \\( U \\otimes I \\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j ], [ 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j], [ 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j ], [ 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j ]]) Gate on both Qubits \\( U \\otimes U\\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.5+0.j , -0. -0.5j, -0. -0.5j, -0.5+0.j ], [ 0. +0.5j, -0.5+0.j , 0.5-0.j , 0. +0.5j], [ 0. +0.5j, 0.5-0.j , -0.5+0.j , 0. +0.5j], [-0.5+0.j , -0. -0.5j, -0. -0.5j, 0.5-0.j ]]) Gates in Parallel and Series \\( (U \\times U) \\otimes (U\\times U) \\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])","title":"Two qubit Circuit"},{"location":"circuits/Two-qubit-circuit/Two-qubit-circuit/#two-qubit-circuits","text":"% matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy","title":"Two Qubit Circuits"},{"location":"circuits/Two-qubit-circuit/Two-qubit-circuit/#double-qubit-circuit","text":"Base states: |00 , |01 , |10 ,|11","title":"Double Qubit Circuit"},{"location":"circuits/Two-qubit-circuit/Two-qubit-circuit/#gate-on-first-qubit","text":"\\( I \\otimes U \\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , -0. -0.707j, 0. +0.j , 0. +0.j ], [ 0. +0.707j, -0.707+0.j , 0. +0.j , 0. +0.j ], [ 0. +0.j , 0. +0.j , 0.707+0.j , -0. -0.707j], [ 0. +0.j , 0. +0.j , 0. +0.707j, -0.707+0.j ]])","title":"Gate on First Qubit"},{"location":"circuits/Two-qubit-circuit/Two-qubit-circuit/#gate-on-second-qubit","text":"\\( U \\otimes I \\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.707+0.j , 0. +0.j , -0. -0.707j, 0. +0.j ], [ 0. +0.j , 0.707+0.j , 0. +0.j , -0. -0.707j], [ 0. +0.707j, 0. +0.j , -0.707+0.j , 0. +0.j ], [ 0. +0.j , 0. +0.707j, 0. +0.j , -0.707+0.j ]])","title":"Gate on Second Qubit"},{"location":"circuits/Two-qubit-circuit/Two-qubit-circuit/#gate-on-both-qubits","text":"\\( U \\otimes U\\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[ 0.5+0.j , -0. -0.5j, -0. -0.5j, -0.5+0.j ], [ 0. +0.5j, -0.5+0.j , 0.5-0.j , 0. +0.5j], [ 0. +0.5j, 0.5-0.j , -0.5+0.j , 0. +0.5j], [-0.5+0.j , -0. -0.5j, -0. -0.5j, 0.5-0.j ]])","title":"Gate on both Qubits"},{"location":"circuits/Two-qubit-circuit/Two-qubit-circuit/#gates-in-parallel-and-series","text":"\\( (U \\times U) \\otimes (U\\times U) \\) qc = QuantumCircuit( 2 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 0 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) qc . u3(np . pi / 2 ,np . pi / 2 ,np . pi / 2 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) getMatrix(qc) matrix([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])","title":"Gates in Parallel and Series"},{"location":"circuits/bell/bell/","text":"Bell States Bell state is constructed with application of \\(\\textbf{Hadamard} \\) and \\(\\textbf{CNOT}\\) gates in two qubit system. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * Bell State Circuit \\( \\beta_{00} \\) def circuit_00 (): qc = QuantumCircuit( 2 , 2 ) qc . h( 0 ) qc . barrier() qc . cx( 0 , 1 ) return qc Circuit Diagram bell_00 = circuit_00() drawCircuit(bell_00) Two qubit system (state vector) Initial state = |00 After application of Hadamard Gate: \\( \\frac{1}{\\sqrt{2}}|00\\rangle + \\frac{1}{\\sqrt{2}}|01\\rangle \\) After application of CNOT Gate: \\( \\frac{1}{\\sqrt{2}}|00 \\rangle + \\frac{1}{\\sqrt{2}}|11 \\rangle \\) def getPhaseSeq (): phaseDic = [] qc0 = QuantumCircuit( 2 , 2 ) qc1 = QuantumCircuit( 2 , 2 ) qc1 . h( 0 ) qc2 = QuantumCircuit( 2 , 2 ) qc2 . h( 0 ) qc2 . cx( 0 , 1 ) for iqc in [qc0,qc1,qc2]: phaseDic . append(getPhase(iqc)) return phaseDic drawPhase(getPhaseSeq()) bell_00 = circuit_00() simCircuit(bell_00) Single qubit states (tensor product) $\\textbf{Question:}$ Can you write Bell state as a tensor product of single qubit state? \\( \\textbf{Answer} \\): No, it is not possible. It is hard to realise. $$\\begin{bmatrix} p \\ q \\end{bmatrix} \\otimes \\begin{bmatrix} r \\ s \\end{bmatrix} = c \\begin{bmatrix} m \\ 0 \\ 0 \\ n \\end{bmatrix}$$ Matrix element (tensor product) $\\textbf{Question:}$ Can we write matrix represented by the Bell circuit as a tensor product of fundamental gate matrices? bell_00 = circuit_00() drawCircuit(bell_00) Based on above Bell circuit, lets construct the matrix representation of the circuit using fundamental gates matrices involved in the circuit. $$H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 1 \\ 1 -1 \\end{bmatrix}; I = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 0 \\ 0 1 \\end{bmatrix}; \\text{CNOT} = \\begin{bmatrix} 1 0 0 0 \\ 0 0 0 1 \\ 0 0 1 0 \\ 0 1 0 0 \\ \\end{bmatrix}$$ Before first barrier $$ I \\otimes H = \\begin{bmatrix} H 0 \\ 0 H \\end{bmatrix} $$ After first barrier \\( \\text{CNOT} \\) Net operation before measurement \\( U = \\text{CNOT} \\times (I \\otimes H) \\) Lets express U matrix using numpy library. I = np . eye( 2 , 2 ) H = 1 / np . sqrt( 2 ) * np . array([[ 1 , 1 ],[ 1 , - 1 ]]) CNOT = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 1 ],[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 0 ]]) I_kron_H = np . kron(I,H) U = np . dot(CNOT,I_kron_H) print (U) [[ 0.70710678 0.70710678 0. 0. ] [ 0. 0. 0.70710678 -0.70710678] [ 0. 0. 0.70710678 0.70710678] [ 0.70710678 -0.70710678 0. 0. ]] We can also observe final ket vector by multiplying it with U matrix. ket_00 = np . array([ 1 , 0 , 0 , 0 ]) np . dot(U,ket_00) array([0.70710678, 0. , 0. , 0.70710678]) Infact we can check our matrix from our circuit shown below by implementing Q is kit's \"unitary_simulator\". bell_00 = circuit_00() plotMatrix(bell_00)","title":"Bell State"},{"location":"circuits/bell/bell/#bell-states","text":"Bell state is constructed with application of \\(\\textbf{Hadamard} \\) and \\(\\textbf{CNOT}\\) gates in two qubit system. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import *","title":"Bell States"},{"location":"circuits/bell/bell/#bell-state-circuit","text":"\\( \\beta_{00} \\) def circuit_00 (): qc = QuantumCircuit( 2 , 2 ) qc . h( 0 ) qc . barrier() qc . cx( 0 , 1 ) return qc Circuit Diagram bell_00 = circuit_00() drawCircuit(bell_00) Two qubit system (state vector) Initial state = |00 After application of Hadamard Gate: \\( \\frac{1}{\\sqrt{2}}|00\\rangle + \\frac{1}{\\sqrt{2}}|01\\rangle \\) After application of CNOT Gate: \\( \\frac{1}{\\sqrt{2}}|00 \\rangle + \\frac{1}{\\sqrt{2}}|11 \\rangle \\) def getPhaseSeq (): phaseDic = [] qc0 = QuantumCircuit( 2 , 2 ) qc1 = QuantumCircuit( 2 , 2 ) qc1 . h( 0 ) qc2 = QuantumCircuit( 2 , 2 ) qc2 . h( 0 ) qc2 . cx( 0 , 1 ) for iqc in [qc0,qc1,qc2]: phaseDic . append(getPhase(iqc)) return phaseDic drawPhase(getPhaseSeq()) bell_00 = circuit_00() simCircuit(bell_00) Single qubit states (tensor product) $\\textbf{Question:}$ Can you write Bell state as a tensor product of single qubit state? \\( \\textbf{Answer} \\): No, it is not possible. It is hard to realise. $$\\begin{bmatrix} p \\ q \\end{bmatrix} \\otimes \\begin{bmatrix} r \\ s \\end{bmatrix} = c \\begin{bmatrix} m \\ 0 \\ 0 \\ n \\end{bmatrix}$$ Matrix element (tensor product) $\\textbf{Question:}$ Can we write matrix represented by the Bell circuit as a tensor product of fundamental gate matrices? bell_00 = circuit_00() drawCircuit(bell_00) Based on above Bell circuit, lets construct the matrix representation of the circuit using fundamental gates matrices involved in the circuit. $$H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 1 \\ 1 -1 \\end{bmatrix}; I = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 0 \\ 0 1 \\end{bmatrix}; \\text{CNOT} = \\begin{bmatrix} 1 0 0 0 \\ 0 0 0 1 \\ 0 0 1 0 \\ 0 1 0 0 \\ \\end{bmatrix}$$ Before first barrier $$ I \\otimes H = \\begin{bmatrix} H 0 \\ 0 H \\end{bmatrix} $$ After first barrier \\( \\text{CNOT} \\) Net operation before measurement \\( U = \\text{CNOT} \\times (I \\otimes H) \\) Lets express U matrix using numpy library. I = np . eye( 2 , 2 ) H = 1 / np . sqrt( 2 ) * np . array([[ 1 , 1 ],[ 1 , - 1 ]]) CNOT = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 0 , 0 , 1 ],[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 0 ]]) I_kron_H = np . kron(I,H) U = np . dot(CNOT,I_kron_H) print (U) [[ 0.70710678 0.70710678 0. 0. ] [ 0. 0. 0.70710678 -0.70710678] [ 0. 0. 0.70710678 0.70710678] [ 0.70710678 -0.70710678 0. 0. ]] We can also observe final ket vector by multiplying it with U matrix. ket_00 = np . array([ 1 , 0 , 0 , 0 ]) np . dot(U,ket_00) array([0.70710678, 0. , 0. , 0.70710678]) Infact we can check our matrix from our circuit shown below by implementing Q is kit's \"unitary_simulator\". bell_00 = circuit_00() plotMatrix(bell_00)","title":"Bell State Circuit"},{"location":"circuits/circuitDecomposition/circuitDecomposition/","text":"Universality: Circuit Decomposition This notebook is from IBM Challange 2020 GitHub Wow! If you managed to solve the first three exercises, congratulations! The fourth problem is supposed to puzzle even the quantum experts among you, so don\u2019t worry if you cannot solve it. If you can, hats off to you! You may recall from your quantum mechanics course that quantum theory is unitary. Therefore, the evolution of any (closed) system can be described by a unitary. But given an arbitrary unitary, can you actually implement it on your quantum computer? \"A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set.\" Every gate you run on the IBM Quantum Experience is transpiled into single qubit rotations and CNOT (CX) gates. We know that these constitute a universal gate set, which implies that any unitary can be implemented using only these gates. However, in general it is not easy to find a good decomposition for an arbitrary unitary. Your task is to find such a decomposition. You are given the following unitary: import numpy as np from qiskit import Aer, QuantumCircuit, execute from qiskit.visualization import plot_histogram from IPython.display import display, Math, Latex from may4_challenge.ex1 import return_state, vec_in_braket, statevec from may4_challenge.ex4 import check_circuit, submit_circuit from qiskit.compiler import transpile import seaborn as sns sns . set() import matplotlib.pyplot as plt Provided Unitary Matrix from may4_challenge.ex4 import get_unitary U = get_unitary() # print(U) print ( U has shape , U . shape) U has shape (16, 16) Trial Zero iqc = QuantumCircuit( 4 ) iqc . iso(U, [ 0 , 1 , 2 , 3 ], []) tiqc = transpile(iqc, basis_gates = [ u3 , cx ],optimization_level = 2 ) check_circuit(tiqc) Circuit stats: ||U-V||_2 = 4.2634217757239e-14 (U is the reference unitary, V is yours, and the global phase has been removed from both of them). Cost is 1663 Something is not right with your circuit: the cost of the circuit is too high (above 1600) Matrix Analysis Lets visualize the Matrix We can look at absolute values of matrix element. def getAbs (U): M = np . eye( 16 , 16 ) for i in range ( 16 ): for j in range ( 16 ): M[i,j] = abs (U[i,j]) return M M = getAbs(U) plt . figure(figsize = [ 15 , 10 ]) sns . heatmap(M, annot = True , fmt = 0.2f ) matplotlib.axes._subplots.AxesSubplot at 0x7fa416aef450 Diagonalization of U from qiskit import BasicAer backend = BasicAer . get_backend( unitary_simulator ) Hqc = QuantumCircuit( 4 ) Hqc . h( 0 ) Hqc . h( 1 ) Hqc . h( 2 ) Hqc . h( 3 ) job = execute(Hqc, backend) H = job . result() . get_unitary(Hqc, decimals = 3 ) H = np . matrix(H) DU = np . dot(np . dot(H,U),H) ADU = getAbs(DU) plt . figure(figsize = [ 10 , 8 ]) sns . heatmap(ADU, annot = True , fmt = 0.1f ) matplotlib.axes._subplots.AxesSubplot at 0x7fa416bab450 What circuit would make such a complicated unitary? Is there some symmetry, or is it random? We just updated Qiskit with the introduction of a quantum circuit library . This library gives users access to a rich set of well-studied circuit families, instances of which can be used as benchmarks (quantum volume), as building blocks in building more complex circuits (adders), or as tools to explore quantum computational advantage over classical computation (instantaneous quantum polynomial complexity circuits). Using only single qubit rotations and CNOT gates, find a quantum circuit that approximates that unitary \\(U \\) by a unitary \\(V \\) up to an error \\( \\varepsilon = 0.01\\), such that \\(\\lVert U - V\\rVert_2 \\leq \\varepsilon\\) ! Note that the norm we are using here is the spectral norm, \\( \\qquad \\lVert A \\rVert_2 = \\max_{\\lVert \\psi \\rVert_2= 1} \\lVert A \\psi \\rVert \\). This can be seen as the largest scaling factor that the matrix $A$ has on any initial (normalized) state $\\psi$. One can show that this norm corresponds to the largest singular value of $A$, i.e., the square root of the largest eigenvalue of the matrix $A^\\dagger A$, where $A^{\\dagger}$ denotes the conjugate transpose of $A$. When you submit a circuit, we remove the global phase of the corresponding unitary $V$ before comparing it with $U$ using the spectral norm. For example, if you submit a circuit that generates $V = \\text{e}^{i\\theta}U$, we remove the global phase $\\text{e}^{i\\theta}$ from $V$ before computing the norm, and you will have a successful submission. As a result, you do not have to worry about matching the desired unitary, $U$, up to a global phase. As the single-qubit gates have a much higher fidelity than the two-qubit gates, we will look at the number of CNOT-gates, \\( n_{cx} \\), and the number of u3-gates, \\( n_{u3}\\), to determine the cost of your decomposition as $$ \\qquad \\text{cost} = 10 \\cdot n_{cx} + n_{u3} $$ Try to optimize the cost of your decomposition. Note that you will need to ensure that your circuit is composed only of \\(u3\\) and \\(cx\\) gates. The exercise is considered correctly solved if your cost is smaller than 1600. For useful tips to complete this exercise as well as pointers for communicating with other participants and asking questions, please take a look at the following repository . You will also find a copy of these exercises, so feel free to edit and experiment with these notebooks. from qiskit import BasicAer backend = BasicAer . get_backend( unitary_simulator ) Hqc = QuantumCircuit( 4 ) Hqc . h( 0 ) Hqc . h( 1 ) Hqc . h( 2 ) Hqc . h( 3 ) job = execute(Hqc, backend) H = job . result() . get_unitary(Hqc, decimals = 3 ) H = np . matrix(H) NU = np . dot(U,H) #NU = np.dot(H,U) ##### build your quantum circuit here qc = QuantumCircuit( 4 ) qc . h( 0 ) qc . h( 1 ) qc . h( 2 ) qc . h( 3 ) qc . iso(NU, [ 0 , 1 , 2 , 3 ], []) #qc.h(0) #qc.h(1) #qc.h(2) #qc.h(3) #qc.draw(output= mpl ) # we draw the circuit qiskit.circuit.instructionset.InstructionSet at 0x7fa484630250 #qc = transpile(qc, basis_gates=[ u3 , cx ],optimization_level = 1) tqc = transpile(qc, basis_gates = [ u3 , cx ],optimization_level = 2 ) #qc.draw(output= mpl ) # we draw the circuit ##### check your quantum circuit by running the next line check_circuit(tqc) Circuit stats: ||U-V||_2 = 7.431794894034265e-15 (U is the reference unitary, V is yours, and the global phase has been removed from both of them). Cost is 331 Great! Your circuit meets all the constrains. Your score is 331. The lower, the better! Feel free to submit your answer and remember you can re-submit a new circuit at any time! You can check whether your circuit is valid before submitting it with check_circuit(qc) . Once you have a valid solution, please submit it by running the following cell (delete the # before submit_circuit ). You can re-submit at any time. #Send the circuit as the final answer, can re-submit at any time #submit_circuit(tqc) Success \ud83c\udf89! Your circuit has been submitted. Return to the IBM Quantum Challenge page and check your score and ranking. Remember that you can submit a circuit as many times as you want. Visualize the Circuit tqc . draw(output = mpl ) # we draw the circuit More Exact Solution qc = QuantumCircuit( 4 ) qc . h( range ( 4 )) qc . unitary(Uprime, qc . qubits) qc . h( range ( 4 )) qc = transpile(qc, basis_gates = [ u3 , cx ], optimization_level = 3 ) check_circuit(qc) qc . draw() # apply operations to your quantum circuit here Circuit stats: ||U-V||_2 = 5.470975623515672e-15 (U is the reference unitary, V is yours, and the global phase has been removed from both of them). Cost is 149 Great! Your circuit meets all the constrains. Your score is 149. The lower, the better! Feel free to submit your answer and remember you can re-submit a new circuit at any time! References https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.iso.html https://github.com/Qiskit/qiskit-tutorials/blob/master/legacy_tutorials/terra/5_using_the_transpiler.ipynb https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/terra/advanced/4_transpiler_passes_and_passmanager.ipynb https://arxiv.org/pdf/1501.06911.pdf","title":"Circuit Decomposition"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#universality-circuit-decomposition","text":"This notebook is from IBM Challange 2020 GitHub Wow! If you managed to solve the first three exercises, congratulations! The fourth problem is supposed to puzzle even the quantum experts among you, so don\u2019t worry if you cannot solve it. If you can, hats off to you! You may recall from your quantum mechanics course that quantum theory is unitary. Therefore, the evolution of any (closed) system can be described by a unitary. But given an arbitrary unitary, can you actually implement it on your quantum computer? \"A set of quantum gates is said to be universal if any unitary transformation of the quantum data can be efficiently approximated arbitrarily well as a sequence of gates in the set.\" Every gate you run on the IBM Quantum Experience is transpiled into single qubit rotations and CNOT (CX) gates. We know that these constitute a universal gate set, which implies that any unitary can be implemented using only these gates. However, in general it is not easy to find a good decomposition for an arbitrary unitary. Your task is to find such a decomposition. You are given the following unitary: import numpy as np from qiskit import Aer, QuantumCircuit, execute from qiskit.visualization import plot_histogram from IPython.display import display, Math, Latex from may4_challenge.ex1 import return_state, vec_in_braket, statevec from may4_challenge.ex4 import check_circuit, submit_circuit from qiskit.compiler import transpile import seaborn as sns sns . set() import matplotlib.pyplot as plt","title":"Universality: Circuit Decomposition"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#provided-unitary-matrix","text":"from may4_challenge.ex4 import get_unitary U = get_unitary() # print(U) print ( U has shape , U . shape) U has shape (16, 16)","title":"Provided Unitary Matrix"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#trial-zero","text":"iqc = QuantumCircuit( 4 ) iqc . iso(U, [ 0 , 1 , 2 , 3 ], []) tiqc = transpile(iqc, basis_gates = [ u3 , cx ],optimization_level = 2 ) check_circuit(tiqc) Circuit stats: ||U-V||_2 = 4.2634217757239e-14 (U is the reference unitary, V is yours, and the global phase has been removed from both of them). Cost is 1663 Something is not right with your circuit: the cost of the circuit is too high (above 1600)","title":"Trial Zero"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#matrix-analysis","text":"Lets visualize the Matrix We can look at absolute values of matrix element. def getAbs (U): M = np . eye( 16 , 16 ) for i in range ( 16 ): for j in range ( 16 ): M[i,j] = abs (U[i,j]) return M M = getAbs(U) plt . figure(figsize = [ 15 , 10 ]) sns . heatmap(M, annot = True , fmt = 0.2f ) matplotlib.axes._subplots.AxesSubplot at 0x7fa416aef450","title":"Matrix Analysis"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#diagonalization-of-u","text":"from qiskit import BasicAer backend = BasicAer . get_backend( unitary_simulator ) Hqc = QuantumCircuit( 4 ) Hqc . h( 0 ) Hqc . h( 1 ) Hqc . h( 2 ) Hqc . h( 3 ) job = execute(Hqc, backend) H = job . result() . get_unitary(Hqc, decimals = 3 ) H = np . matrix(H) DU = np . dot(np . dot(H,U),H) ADU = getAbs(DU) plt . figure(figsize = [ 10 , 8 ]) sns . heatmap(ADU, annot = True , fmt = 0.1f ) matplotlib.axes._subplots.AxesSubplot at 0x7fa416bab450","title":"Diagonalization of U"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#what-circuit-would-make-such-a-complicated-unitary","text":"Is there some symmetry, or is it random? We just updated Qiskit with the introduction of a quantum circuit library . This library gives users access to a rich set of well-studied circuit families, instances of which can be used as benchmarks (quantum volume), as building blocks in building more complex circuits (adders), or as tools to explore quantum computational advantage over classical computation (instantaneous quantum polynomial complexity circuits). Using only single qubit rotations and CNOT gates, find a quantum circuit that approximates that unitary \\(U \\) by a unitary \\(V \\) up to an error \\( \\varepsilon = 0.01\\), such that \\(\\lVert U - V\\rVert_2 \\leq \\varepsilon\\) ! Note that the norm we are using here is the spectral norm, \\( \\qquad \\lVert A \\rVert_2 = \\max_{\\lVert \\psi \\rVert_2= 1} \\lVert A \\psi \\rVert \\). This can be seen as the largest scaling factor that the matrix $A$ has on any initial (normalized) state $\\psi$. One can show that this norm corresponds to the largest singular value of $A$, i.e., the square root of the largest eigenvalue of the matrix $A^\\dagger A$, where $A^{\\dagger}$ denotes the conjugate transpose of $A$. When you submit a circuit, we remove the global phase of the corresponding unitary $V$ before comparing it with $U$ using the spectral norm. For example, if you submit a circuit that generates $V = \\text{e}^{i\\theta}U$, we remove the global phase $\\text{e}^{i\\theta}$ from $V$ before computing the norm, and you will have a successful submission. As a result, you do not have to worry about matching the desired unitary, $U$, up to a global phase. As the single-qubit gates have a much higher fidelity than the two-qubit gates, we will look at the number of CNOT-gates, \\( n_{cx} \\), and the number of u3-gates, \\( n_{u3}\\), to determine the cost of your decomposition as $$ \\qquad \\text{cost} = 10 \\cdot n_{cx} + n_{u3} $$ Try to optimize the cost of your decomposition. Note that you will need to ensure that your circuit is composed only of \\(u3\\) and \\(cx\\) gates. The exercise is considered correctly solved if your cost is smaller than 1600. For useful tips to complete this exercise as well as pointers for communicating with other participants and asking questions, please take a look at the following repository . You will also find a copy of these exercises, so feel free to edit and experiment with these notebooks. from qiskit import BasicAer backend = BasicAer . get_backend( unitary_simulator ) Hqc = QuantumCircuit( 4 ) Hqc . h( 0 ) Hqc . h( 1 ) Hqc . h( 2 ) Hqc . h( 3 ) job = execute(Hqc, backend) H = job . result() . get_unitary(Hqc, decimals = 3 ) H = np . matrix(H) NU = np . dot(U,H) #NU = np.dot(H,U) ##### build your quantum circuit here qc = QuantumCircuit( 4 ) qc . h( 0 ) qc . h( 1 ) qc . h( 2 ) qc . h( 3 ) qc . iso(NU, [ 0 , 1 , 2 , 3 ], []) #qc.h(0) #qc.h(1) #qc.h(2) #qc.h(3) #qc.draw(output= mpl ) # we draw the circuit qiskit.circuit.instructionset.InstructionSet at 0x7fa484630250 #qc = transpile(qc, basis_gates=[ u3 , cx ],optimization_level = 1) tqc = transpile(qc, basis_gates = [ u3 , cx ],optimization_level = 2 ) #qc.draw(output= mpl ) # we draw the circuit ##### check your quantum circuit by running the next line check_circuit(tqc) Circuit stats: ||U-V||_2 = 7.431794894034265e-15 (U is the reference unitary, V is yours, and the global phase has been removed from both of them). Cost is 331 Great! Your circuit meets all the constrains. Your score is 331. The lower, the better! Feel free to submit your answer and remember you can re-submit a new circuit at any time! You can check whether your circuit is valid before submitting it with check_circuit(qc) . Once you have a valid solution, please submit it by running the following cell (delete the # before submit_circuit ). You can re-submit at any time. #Send the circuit as the final answer, can re-submit at any time #submit_circuit(tqc) Success \ud83c\udf89! Your circuit has been submitted. Return to the IBM Quantum Challenge page and check your score and ranking. Remember that you can submit a circuit as many times as you want.","title":"What circuit would make such a complicated unitary?"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#visualize-the-circuit","text":"tqc . draw(output = mpl ) # we draw the circuit","title":"Visualize the Circuit"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#more-exact-solution","text":"qc = QuantumCircuit( 4 ) qc . h( range ( 4 )) qc . unitary(Uprime, qc . qubits) qc . h( range ( 4 )) qc = transpile(qc, basis_gates = [ u3 , cx ], optimization_level = 3 ) check_circuit(qc) qc . draw() # apply operations to your quantum circuit here Circuit stats: ||U-V||_2 = 5.470975623515672e-15 (U is the reference unitary, V is yours, and the global phase has been removed from both of them). Cost is 149 Great! Your circuit meets all the constrains. Your score is 149. The lower, the better! Feel free to submit your answer and remember you can re-submit a new circuit at any time!","title":"More Exact Solution"},{"location":"circuits/circuitDecomposition/circuitDecomposition/#references","text":"https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.iso.html https://github.com/Qiskit/qiskit-tutorials/blob/master/legacy_tutorials/terra/5_using_the_transpiler.ipynb https://github.com/Qiskit/qiskit-tutorials/blob/master/tutorials/terra/advanced/4_transpiler_passes_and_passmanager.ipynb https://arxiv.org/pdf/1501.06911.pdf","title":"References"},{"location":"circuits/universality/universality/","text":"Universality % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import execute,BasicAer from qiskit import QuantumRegister,ClassicalRegister from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy $$ R_x(\\theta) = e^{i \\frac{\\theta}{2} X} $$ $$R_x(\\theta) = e^{i \\frac{\\theta}{2} X} = I + i \\frac{\\theta}{2} X + \\frac{(i \\frac{\\theta}{2} X)^{2}}{2!} + ...$$ qc = QuantumCircuit( 1 , 1 ) qc . rx(np . pi / 100 , 0 ) qcm1 = qc . copy() I = np . eye( 2 , 2 ) X = np . array([[ 0 , 1 ],[ 1 , 0 ]]) U = I + ( 0 + 1 j) * (np . pi / ( 2 * 100 )) * X plotMatrix(U) backend = BasicAer . get_backend( unitary_simulator ) job = execute(qcm1, backend) ndArray = job . result() . get_unitary(qcm1, decimals = 3 ) Matrix = np . matrix(ndArray) plotMatrix(Matrix) Example 1 $$U = e^{i\\frac{\\theta}{2} X \\otimes X \\otimes X}$$ QCs = [] n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 2 ]) qc . cx(q[ 0 ],q[ 1 ]) qc . barrier() QCs . append(qc . copy()) qc . rx(np . pi / 10 ,q[ 0 ]) qc . barrier() QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 1 ]) qc . cx(q[ 0 ],q[ 2 ]) qcm2 = qc . copy() qc . barrier() QCs . append(qc . copy()) qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Phase phaseDict = getPhaseDict(QCs) plotiPhaseCircle(phaseDict,depth = len (phaseDict),path = uplot ,show = True ,save = False ) Figure size 432x288 with 0 Axes Matrix I3 = np . eye( 8 , 8 ) X = np . array([[ 0 , 1 ],[ 1 , 0 ]]) XXX = np . kron(np . kron(X,X),X) U = I3 + ( 0 + 1 j) * (np . pi / ( 2 * 10 )) * XXX plotMatrix(U) backend = BasicAer . get_backend( unitary_simulator ) job = execute(qcm2, backend) ndArray = job . result() . get_unitary(qcm2, decimals = 3 ) Matrix = np . matrix(ndArray) plotMatrix(Matrix) Example 2 $$U = e^{i\\frac{\\theta}{2} Z \\otimes Z \\otimes Z}$$ QCs = [] n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) QCs . append(qc . copy()) qc . h(q[ 0 ]) qc . h(q[ 1 ]) qc . h(q[ 2 ]) qc . barrier() QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 2 ]) qc . cx(q[ 0 ],q[ 1 ]) qc . barrier() QCs . append(qc . copy()) qc . rx(np . pi / 6 ,q[ 0 ]) qc . barrier() QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 1 ]) qc . cx(q[ 0 ],q[ 2 ]) qc . barrier() QCs . append(qc . copy()) qc . h(q[ 2 ]) qc . h(q[ 1 ]) qc . h(q[ 0 ]) qcm3 = qc . copy() qc . barrier() QCs . append(qc . copy()) qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Phase phaseDict = getPhaseDict(QCs) plotiPhaseCircle(phaseDict,depth = len (phaseDict),path = uplot ,show = True ,save = False ) Figure size 432x288 with 0 Axes Matrix I3 = np . eye( 8 , 8 ) Z = np . array([[ 0 , 1 ],[ 0 , - 1 ]]) ZZZ = np . kron(np . kron(Z,Z),Z) U = I3 + ( 0 + 1 j) * (np . pi / ( 2 * 10 )) * ZZZ plotMatrix(U) backend = BasicAer . get_backend( unitary_simulator ) job = execute(qcm3, backend) ndArray = job . result() . get_unitary(qcm3, decimals = 3 ) Matrix = np . matrix(ndArray) plotMatrix(Matrix)","title":"Universality"},{"location":"circuits/universality/universality/#universality","text":"% matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import execute,BasicAer from qiskit import QuantumRegister,ClassicalRegister from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy $$ R_x(\\theta) = e^{i \\frac{\\theta}{2} X} $$ $$R_x(\\theta) = e^{i \\frac{\\theta}{2} X} = I + i \\frac{\\theta}{2} X + \\frac{(i \\frac{\\theta}{2} X)^{2}}{2!} + ...$$ qc = QuantumCircuit( 1 , 1 ) qc . rx(np . pi / 100 , 0 ) qcm1 = qc . copy() I = np . eye( 2 , 2 ) X = np . array([[ 0 , 1 ],[ 1 , 0 ]]) U = I + ( 0 + 1 j) * (np . pi / ( 2 * 100 )) * X plotMatrix(U) backend = BasicAer . get_backend( unitary_simulator ) job = execute(qcm1, backend) ndArray = job . result() . get_unitary(qcm1, decimals = 3 ) Matrix = np . matrix(ndArray) plotMatrix(Matrix)","title":"Universality"},{"location":"circuits/universality/universality/#example-1","text":"$$U = e^{i\\frac{\\theta}{2} X \\otimes X \\otimes X}$$ QCs = [] n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 2 ]) qc . cx(q[ 0 ],q[ 1 ]) qc . barrier() QCs . append(qc . copy()) qc . rx(np . pi / 10 ,q[ 0 ]) qc . barrier() QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 1 ]) qc . cx(q[ 0 ],q[ 2 ]) qcm2 = qc . copy() qc . barrier() QCs . append(qc . copy()) qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Phase phaseDict = getPhaseDict(QCs) plotiPhaseCircle(phaseDict,depth = len (phaseDict),path = uplot ,show = True ,save = False ) Figure size 432x288 with 0 Axes Matrix I3 = np . eye( 8 , 8 ) X = np . array([[ 0 , 1 ],[ 1 , 0 ]]) XXX = np . kron(np . kron(X,X),X) U = I3 + ( 0 + 1 j) * (np . pi / ( 2 * 10 )) * XXX plotMatrix(U) backend = BasicAer . get_backend( unitary_simulator ) job = execute(qcm2, backend) ndArray = job . result() . get_unitary(qcm2, decimals = 3 ) Matrix = np . matrix(ndArray) plotMatrix(Matrix)","title":"Example 1"},{"location":"circuits/universality/universality/#example-2","text":"$$U = e^{i\\frac{\\theta}{2} Z \\otimes Z \\otimes Z}$$ QCs = [] n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) QCs . append(qc . copy()) qc . h(q[ 0 ]) qc . h(q[ 1 ]) qc . h(q[ 2 ]) qc . barrier() QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 2 ]) qc . cx(q[ 0 ],q[ 1 ]) qc . barrier() QCs . append(qc . copy()) qc . rx(np . pi / 6 ,q[ 0 ]) qc . barrier() QCs . append(qc . copy()) qc . cx(q[ 0 ],q[ 1 ]) qc . cx(q[ 0 ],q[ 2 ]) qc . barrier() QCs . append(qc . copy()) qc . h(q[ 2 ]) qc . h(q[ 1 ]) qc . h(q[ 0 ]) qcm3 = qc . copy() qc . barrier() QCs . append(qc . copy()) qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Phase phaseDict = getPhaseDict(QCs) plotiPhaseCircle(phaseDict,depth = len (phaseDict),path = uplot ,show = True ,save = False ) Figure size 432x288 with 0 Axes Matrix I3 = np . eye( 8 , 8 ) Z = np . array([[ 0 , 1 ],[ 0 , - 1 ]]) ZZZ = np . kron(np . kron(Z,Z),Z) U = I3 + ( 0 + 1 j) * (np . pi / ( 2 * 10 )) * ZZZ plotMatrix(U) backend = BasicAer . get_backend( unitary_simulator ) job = execute(qcm3, backend) ndArray = job . result() . get_unitary(qcm3, decimals = 3 ) Matrix = np . matrix(ndArray) plotMatrix(Matrix)","title":"Example 2"},{"location":"cryptography/cryptography/","text":"Quantum Cryptography This Notebook is taken from IBM Challenge 2020, GitHub BB84 , is a cryptography protocol developed in 1984 by one of our most famous IBMers, Charles Bennett, together with his colleague Gilles Brassard. The goal of the BB84 protocol is to create a secret key between two parties, Alice and Bob, that can then be used by both parties to encrypt and decrypt a hidden message. In this exercise we will guide you through the different steps of the protocol to create such a secret key to decrypt our encrypted message. BB84 protocol Let's walk through the steps of the BB84 protocol: In the first step, Alice chooses two random bit strings, $k$ and $b$, that each consist of \\( n \\) bits. Her bit string $k$ contains the actual bits she wants to encode (out of which the key will later be formed), while $b$ determines the bases in which she will encode her bits. For \\( b_i=0 \\) (i.e., if the \\( i^{th} \\) bit is zero), she encodes the \\( i^{th} \\) qubit in the standard \\( {|0\\rangle, |1\\rangle } \\) basis, while for \\(b_i=1\\), she encodes it in the \\( {|+\\rangle, |-\\rangle } \\) basis, where \\( |+\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle +|1\\rangle) \\), \\( |-\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle -|1\\rangle) \\). This becomes more illustrative when representing each basis by two perpendicular arrows, where the two different bases are rotated by \\( 45^\\circ \\). The encoding of each qubit \\( q_i \\) would therefore look like the following: After encoding her \\( n \\) qubits, Alice sends these qubits to Bob. Bob also chooses a random bit string \\( \\tilde{b} \\) consisting of \\( n \\) bits that determines in which bases he is going to perform measurements. He stores the outcomes of his measurements \\( \\tilde{k_i} \\) together with the corresponding basis bits \\( \\tilde{b_i} \\) in a table. Next, Alice and Bob compare their basis bits \\( b_i \\) and \\( \\tilde{b}_i \\). Whenever \\( b_i \\neq \\tilde{b}_i \\), Bob measured in a different basis than Alice's qubit was encoded in, so he gets each outcome with probability \\( \\frac{1}{2} \\). Alice and Bob therefore discard all key bits corresponding to these basis bits. If \\( b_i = \\tilde{b}_i \\), however, they prepared and measured the qubit in the same basis, so (unless someone eavesdropped) Bob will get the key bit that Alice encoded, \\( \\tilde{k}_i = k_i \\). These outcomes then compose the key. An illustrated example Suppose Alice's random bit strings are ( k= 0111001 ) and ( b= 1101000 ) and Bob's random bit string is (\\( \\tilde{b} \\)= 1001101 ). Try to understand the other entries in the table below. Note that in the case where the basis bits are different, Bob has a 50% chance to get each outcome, so here one of them was chosen randomly. The key produced in this example would be '0110'. To make sure that the key is secret and correct, Alice and Bob would \"sacrifice\" some of their key bits to check that no one eavesdropped. If someone had measured a qubit on the way, this could have changed the state of that qubit and with probability \\(\\frac{1}{4} \\), Bob's and Alice's key bits will be different. By checking $m$ bits, the probability to not notice an eavesdropper decreases as \\( \\left(\\frac{3}{4}\\right)^m \\). Thus, if they check enough bits and they are all the same, they can assume that no one eavesdropped and their key is secret. However, to keep things simple, we will not perfom these tests in this excercise. Instead, all bits of the key will be used. Message encrpytion Once a secret key is distributed, Alice can encrypt her message by using the so-called one-time pad technique: she simply adds the key bits on top of her secret message bits that she wants to send. Using the example above, her key is \\( \\text{key}\\)= 0110 . If her secret message bit string is ( m= 1100 ), the encrypted message will be \\( c=m\\oplus \\text{key} \\mod 2 \\)= 1010 . Bob can then decrypt the message by adding his key on that encrypted message, \\( m=c\\oplus \\text{key} \\mod 2 \\). The challenge In the following four tasks, you play the role of Bob. You will create such a secret key with Alice and use it to decrypt the encrypted message from her. For useful tips to complete this exercise as well as pointers for communicating with other participants and asking questions, please take a look at the following repository . You will also find a copy of these exercises, so feel free to edit and experiment with these notebooks. How we simulate this protocol in Qiskit In this exercise, there are three steps. Each of these three steps is completed $n=100$ times. Before the protocol begins, Alice will choose two random bit strings, $k$ and $b$. Alice will prepare each qubit using the function Alice_prepare_qubit , which is already written for you. Bob measures his qubit using a specific set of bases, which we have given you in a variable called bases . You will supply the procedure that Bob takes in the function Bob_measure_qubit . A quantum circuit for this sequence of operations is created. It will be called this_qubit_circuit for each qubit, and all such circuits are collected together in an array called all_qubit_circuits . We have supplied the code to do this. Finally, we run all_qubit_circuits on the IBM high-performance cloud simulator called ibmq_qasm_simulator and collect the results of the measurements into a bitstring called bits . We have supplied the code to do this. You will then follow the protocol to decrypt a message using the extracted key from the BB84 protocol. i) Execute step 2 of the BB84 protocol to get your bitstring To do so, you need a random bit string \\(\\tilde{b}\\) that determines the bases in which you should perform the measurements. In order to reproduce the key that we used to encrypt our secret message, we provide you with this \"random\" bases bit string of 100 bits that uses seed \"84\". Perform measurements in the bases corresponding to the given bit string and return the outcome as a bit string in the form \\( \\tilde{b} 0 \\tilde{b}_1...\\tilde{b} {n-1} \\). Note that Qiskit returns outcomes always in reverse order, so if \\( |\\tilde{q}_0\\rangle = |0 \\rangle \\) and \\(|\\tilde{q}_1\\rangle = |\\tilde{q}_2\\rangle = |1 \\rangle \\) , it will return the outcome '110'. You can check whether your bit string is correct by check_bits(bitstring) . % matplotlib inline # Importing standard Qiskit libraries import random from qiskit import execute, Aer, IBMQ from qiskit.tools.jupyter import * from qiskit.visualization import * from may4_challenge.ex3 import alice_prepare_qubit, check_bits, check_key, check_decrypted, show_message from IPython.display import display, Math, Latex from may4_challenge.ex1 import return_state, vec_in_braket, statevec # Configuring account provider = IBMQ . load_account() backend = provider . get_backend( ibmq_qasm_simulator ) # with this simulator it wouldn t work \\ # Initial setup random . seed( 84 ) # do not change this seed, otherwise you will get a different key # This is your random bit string that determines your bases numqubits = 100 bob_bases = str ( {0:0100b} . format(random . getrandbits(numqubits))) def bb84 (): print ( Bob \\ s bases: , bob_bases) # Now Alice will send her bits one by one... all_qubit_circuits = [] for qubit_index in range (numqubits): # This is Alice creating the qubit thisqubit_circuit = alice_prepare_qubit(qubit_index) # This is Bob finishing the protocol below bob_measure_qubit(bob_bases, qubit_index, thisqubit_circuit) # We collect all these circuits and put them in an array all_qubit_circuits . append(thisqubit_circuit) # Now execute all the circuits for each qubit results = execute(all_qubit_circuits, backend = backend, shots = 1 ) . result() # And combine the results bits = for qubit_index in range (numqubits): bits += [measurement for measurement in results . get_counts(qubit_index)][ 0 ] return bits # Here is your task def bob_measure_qubit (bob_bases, qubit_index, qubit_circuit): # insert your code here to measure Alice s bits current_base_element = bob_bases[qubit_index] #print(current_base_element) #state = statevec(qubit_circuit) # determine final state after running the circuit #display(Math(vec_in_braket(state.data))) if current_base_element == 0 : qubit_circuit . measure( 0 , 0 ) elif current_base_element == 1 : qubit_circuit . h( 0 ) qubit_circuit . measure( 0 , 0 ) bits = bb84() print ( Bob \\ s bits: , bits) check_bits(bits) ibmqfactory.load_account:WARNING:2020-05-05 00:37:47,366: Credentials are already in use. The existing account in the session will be replaced. Bob s bases: 1100111010011111111111110100000111010100100010011001001110100001010010111011010001011001111111011111 Bob s bits: 1000001000011100001110000010000111100101000111000101010010000110000000111100000101100001101101001001 So far, so good \ud83c\udf89! You got the right bits! After you performed your measurements, Alice announces her bases bits: $$ b = 1000000000010001111111001101100101000111110100110111111000110000011000001001100011100111010010000110 $$ ii) Execute step 3 of the BB84 protocol to extract the key To do so, compare Alice's bases bits $b$ to your bases bits \\( \\tilde{b} \\) (given in the previous step) and extract the key by keeping only the outcomes when your bases were the same. You can check whether your key is correct by check_key(key) . alice_bases = 10000000000100011111110011011001010001111101001101111110001100000110000010011000111 \\ 00111010010000110 # Alice s bases bits key = for i in range ( len (bits)): if alice_bases[i] == bob_bases[i]: key = key + bits[i] print (key) check_key(key) 10000010001110010011101001010000110000110011100000 So far, so good \ud83c\udf89! You got the right key! Using this key, Alice can now send you her private encrypted message. While for full security a key would only be used once, she will now use her 50-bit-long key four times in a row to encrypt her 200-bit-long message. Her encrypted message is $$ m = 0011011010100011101000001100010000001000011000101110110111100111111110001111100011100101011010111010\\ \\qquad 1110100011101010010111111100101000011010011011011011101111010111000101111111001010101001100101111011 $$ iii) Decrypt the message using the extracted key The message encryption section in the introduction describes how to do so. You can check whether your decrypted message bit string is correct by check_decrypted(decrypted) . m = 0011011010100011101000001100010000001000011000101110110111100111111110001111100011100101011010111010111010001 \\ 1101010010111111100101000011010011011011011101111010111000101111111001010101001100101111011 # encrypted message decrypted = for i,t in enumerate (m): #print(i,t) im = ( int (t) + int (key[i % 50 ])) % 2 decrypted = decrypted + str (im) check_decrypted(decrypted) So far, so good \ud83c\udf89! You decrypted the message! Of course there is an actual message encoded in this bit string. To encode letters, Alice used Morse code (see here for more details: https://en.wikipedia.org/wiki/Morse_code). However, as she could only send zeros and ones and wanted to keep her message as short as possible, she encoded a dot (\"dit\") as '1' a dash (\"dah\") as '11' an intra-character gap (between each dot and dash within a character) as '0' a short gap (that separates letters) as '00' a medium gap (that separates words) as '000'. Here is an example: iv) Try to decode Alice's message! In a first step, convert the decrypted message from above into morse code. In a second step, use the provided dictionary to decode the morse code. Copy and paste the solution string on the IBM Quantum Challenge page to complete the exercise and track your progress. decrypted 10110100100110101001101010010100110010110101101011001101011010011011011001101100110101011010010110100110101011010011011001011001101011011001010101011001101101011001010110010110011010011001010110011011 MORSE_CODE_DICT = { a : .- , b : -... , c : -.-. , d : -.. , e : . , f : ..-. , g : --. , h : .... , i : .. , j : .--- , k : -.- , l : .-.. , m : -- , n : -. , o : --- , p : .--. , q : --.- , r : .-. , s : ... , t : - , u : ..- , v : ...- , w : .-- , x : -..- , y : -.-- , z : --.. , 1 : .---- , 2 : ..--- , 3 : ...-- , 4 : ....- , 5 : ..... , 6 : -.... , 7 : --... , 8 : ---.. , 9 : ----. , 0 : ----- , , : --..-- , . : .-.-.- , ? : ..--.. , / : -..-. , - : -....- , ( : -.--. , ) : -.--.- } MCODE = dec = decrypted while len (dec) 3 : if dec[ 0 ] == 1 and dec[ 0 : 2 ] != 11 : MCODE = MCODE + . dec = dec[ 1 :] if dec[ 0 : 2 ] == 11 and len (dec) 1 : MCODE = MCODE + - dec = dec[ 2 :] if dec[ 0 ] == 0 and dec[ 0 : 2 ] != 00 and dec[ 0 : 3 ] != 000 and len (dec) 3 : MCODE = MCODE + dec = dec[ 1 :] if dec[ 0 : 2 ] == 00 and dec[ 0 : 3 ] != 000 and len (dec) 3 : MCODE = MCODE + + # seperates letters dec = dec[ 2 :] if dec[ 0 : 3 ] == 000 and i len (dec) - 3 and len (dec) 3 : MCODE = MCODE + x # seperates words dec = dec[ 3 :] MCODE = MCODE + -- RDICT = {} for k,v in MORSE_CODE_DICT . items(): RDICT . update({v:k}) MID = MCODE . split( + ) solution = for item in MID: #print(RDICT[item]) solution = solution + RDICT[item] solution = solution[ 0 : - 1 ] + m show_message(solution) Congratulations \ud83c\udf89! Submit the following text reddit.com/r/may4quantum on the IBM Quantum Challenge page to see if you are correct.","title":"Quantum Cryptography"},{"location":"cryptography/cryptography/#quantum-cryptography","text":"This Notebook is taken from IBM Challenge 2020, GitHub BB84 , is a cryptography protocol developed in 1984 by one of our most famous IBMers, Charles Bennett, together with his colleague Gilles Brassard. The goal of the BB84 protocol is to create a secret key between two parties, Alice and Bob, that can then be used by both parties to encrypt and decrypt a hidden message. In this exercise we will guide you through the different steps of the protocol to create such a secret key to decrypt our encrypted message.","title":"Quantum Cryptography"},{"location":"cryptography/cryptography/#bb84-protocol","text":"Let's walk through the steps of the BB84 protocol: In the first step, Alice chooses two random bit strings, $k$ and $b$, that each consist of \\( n \\) bits. Her bit string $k$ contains the actual bits she wants to encode (out of which the key will later be formed), while $b$ determines the bases in which she will encode her bits. For \\( b_i=0 \\) (i.e., if the \\( i^{th} \\) bit is zero), she encodes the \\( i^{th} \\) qubit in the standard \\( {|0\\rangle, |1\\rangle } \\) basis, while for \\(b_i=1\\), she encodes it in the \\( {|+\\rangle, |-\\rangle } \\) basis, where \\( |+\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle +|1\\rangle) \\), \\( |-\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle -|1\\rangle) \\). This becomes more illustrative when representing each basis by two perpendicular arrows, where the two different bases are rotated by \\( 45^\\circ \\). The encoding of each qubit \\( q_i \\) would therefore look like the following: After encoding her \\( n \\) qubits, Alice sends these qubits to Bob. Bob also chooses a random bit string \\( \\tilde{b} \\) consisting of \\( n \\) bits that determines in which bases he is going to perform measurements. He stores the outcomes of his measurements \\( \\tilde{k_i} \\) together with the corresponding basis bits \\( \\tilde{b_i} \\) in a table. Next, Alice and Bob compare their basis bits \\( b_i \\) and \\( \\tilde{b}_i \\). Whenever \\( b_i \\neq \\tilde{b}_i \\), Bob measured in a different basis than Alice's qubit was encoded in, so he gets each outcome with probability \\( \\frac{1}{2} \\). Alice and Bob therefore discard all key bits corresponding to these basis bits. If \\( b_i = \\tilde{b}_i \\), however, they prepared and measured the qubit in the same basis, so (unless someone eavesdropped) Bob will get the key bit that Alice encoded, \\( \\tilde{k}_i = k_i \\). These outcomes then compose the key.","title":"BB84 protocol"},{"location":"cryptography/cryptography/#an-illustrated-example","text":"Suppose Alice's random bit strings are ( k= 0111001 ) and ( b= 1101000 ) and Bob's random bit string is (\\( \\tilde{b} \\)= 1001101 ). Try to understand the other entries in the table below. Note that in the case where the basis bits are different, Bob has a 50% chance to get each outcome, so here one of them was chosen randomly. The key produced in this example would be '0110'. To make sure that the key is secret and correct, Alice and Bob would \"sacrifice\" some of their key bits to check that no one eavesdropped. If someone had measured a qubit on the way, this could have changed the state of that qubit and with probability \\(\\frac{1}{4} \\), Bob's and Alice's key bits will be different. By checking $m$ bits, the probability to not notice an eavesdropper decreases as \\( \\left(\\frac{3}{4}\\right)^m \\). Thus, if they check enough bits and they are all the same, they can assume that no one eavesdropped and their key is secret. However, to keep things simple, we will not perfom these tests in this excercise. Instead, all bits of the key will be used.","title":"An illustrated example"},{"location":"cryptography/cryptography/#message-encrpytion","text":"Once a secret key is distributed, Alice can encrypt her message by using the so-called one-time pad technique: she simply adds the key bits on top of her secret message bits that she wants to send. Using the example above, her key is \\( \\text{key}\\)= 0110 . If her secret message bit string is ( m= 1100 ), the encrypted message will be \\( c=m\\oplus \\text{key} \\mod 2 \\)= 1010 . Bob can then decrypt the message by adding his key on that encrypted message, \\( m=c\\oplus \\text{key} \\mod 2 \\).","title":"Message encrpytion"},{"location":"cryptography/cryptography/#the-challenge","text":"In the following four tasks, you play the role of Bob. You will create such a secret key with Alice and use it to decrypt the encrypted message from her. For useful tips to complete this exercise as well as pointers for communicating with other participants and asking questions, please take a look at the following repository . You will also find a copy of these exercises, so feel free to edit and experiment with these notebooks.","title":"The challenge"},{"location":"cryptography/cryptography/#how-we-simulate-this-protocol-in-qiskit","text":"In this exercise, there are three steps. Each of these three steps is completed $n=100$ times. Before the protocol begins, Alice will choose two random bit strings, $k$ and $b$. Alice will prepare each qubit using the function Alice_prepare_qubit , which is already written for you. Bob measures his qubit using a specific set of bases, which we have given you in a variable called bases . You will supply the procedure that Bob takes in the function Bob_measure_qubit . A quantum circuit for this sequence of operations is created. It will be called this_qubit_circuit for each qubit, and all such circuits are collected together in an array called all_qubit_circuits . We have supplied the code to do this. Finally, we run all_qubit_circuits on the IBM high-performance cloud simulator called ibmq_qasm_simulator and collect the results of the measurements into a bitstring called bits . We have supplied the code to do this. You will then follow the protocol to decrypt a message using the extracted key from the BB84 protocol.","title":"How we simulate this protocol in Qiskit"},{"location":"cryptography/cryptography/#i-execute-step-2-of-the-bb84-protocol-to-get-your-bitstring","text":"To do so, you need a random bit string \\(\\tilde{b}\\) that determines the bases in which you should perform the measurements. In order to reproduce the key that we used to encrypt our secret message, we provide you with this \"random\" bases bit string of 100 bits that uses seed \"84\". Perform measurements in the bases corresponding to the given bit string and return the outcome as a bit string in the form \\( \\tilde{b} 0 \\tilde{b}_1...\\tilde{b} {n-1} \\). Note that Qiskit returns outcomes always in reverse order, so if \\( |\\tilde{q}_0\\rangle = |0 \\rangle \\) and \\(|\\tilde{q}_1\\rangle = |\\tilde{q}_2\\rangle = |1 \\rangle \\) , it will return the outcome '110'. You can check whether your bit string is correct by check_bits(bitstring) . % matplotlib inline # Importing standard Qiskit libraries import random from qiskit import execute, Aer, IBMQ from qiskit.tools.jupyter import * from qiskit.visualization import * from may4_challenge.ex3 import alice_prepare_qubit, check_bits, check_key, check_decrypted, show_message from IPython.display import display, Math, Latex from may4_challenge.ex1 import return_state, vec_in_braket, statevec # Configuring account provider = IBMQ . load_account() backend = provider . get_backend( ibmq_qasm_simulator ) # with this simulator it wouldn t work \\ # Initial setup random . seed( 84 ) # do not change this seed, otherwise you will get a different key # This is your random bit string that determines your bases numqubits = 100 bob_bases = str ( {0:0100b} . format(random . getrandbits(numqubits))) def bb84 (): print ( Bob \\ s bases: , bob_bases) # Now Alice will send her bits one by one... all_qubit_circuits = [] for qubit_index in range (numqubits): # This is Alice creating the qubit thisqubit_circuit = alice_prepare_qubit(qubit_index) # This is Bob finishing the protocol below bob_measure_qubit(bob_bases, qubit_index, thisqubit_circuit) # We collect all these circuits and put them in an array all_qubit_circuits . append(thisqubit_circuit) # Now execute all the circuits for each qubit results = execute(all_qubit_circuits, backend = backend, shots = 1 ) . result() # And combine the results bits = for qubit_index in range (numqubits): bits += [measurement for measurement in results . get_counts(qubit_index)][ 0 ] return bits # Here is your task def bob_measure_qubit (bob_bases, qubit_index, qubit_circuit): # insert your code here to measure Alice s bits current_base_element = bob_bases[qubit_index] #print(current_base_element) #state = statevec(qubit_circuit) # determine final state after running the circuit #display(Math(vec_in_braket(state.data))) if current_base_element == 0 : qubit_circuit . measure( 0 , 0 ) elif current_base_element == 1 : qubit_circuit . h( 0 ) qubit_circuit . measure( 0 , 0 ) bits = bb84() print ( Bob \\ s bits: , bits) check_bits(bits) ibmqfactory.load_account:WARNING:2020-05-05 00:37:47,366: Credentials are already in use. The existing account in the session will be replaced. Bob s bases: 1100111010011111111111110100000111010100100010011001001110100001010010111011010001011001111111011111 Bob s bits: 1000001000011100001110000010000111100101000111000101010010000110000000111100000101100001101101001001 So far, so good \ud83c\udf89! You got the right bits! After you performed your measurements, Alice announces her bases bits: $$ b = 1000000000010001111111001101100101000111110100110111111000110000011000001001100011100111010010000110 $$","title":"i) Execute step 2 of the BB84 protocol to get your bitstring"},{"location":"cryptography/cryptography/#ii-execute-step-3-of-the-bb84-protocol-to-extract-the-key","text":"To do so, compare Alice's bases bits $b$ to your bases bits \\( \\tilde{b} \\) (given in the previous step) and extract the key by keeping only the outcomes when your bases were the same. You can check whether your key is correct by check_key(key) . alice_bases = 10000000000100011111110011011001010001111101001101111110001100000110000010011000111 \\ 00111010010000110 # Alice s bases bits key = for i in range ( len (bits)): if alice_bases[i] == bob_bases[i]: key = key + bits[i] print (key) check_key(key) 10000010001110010011101001010000110000110011100000 So far, so good \ud83c\udf89! You got the right key! Using this key, Alice can now send you her private encrypted message. While for full security a key would only be used once, she will now use her 50-bit-long key four times in a row to encrypt her 200-bit-long message. Her encrypted message is $$ m = 0011011010100011101000001100010000001000011000101110110111100111111110001111100011100101011010111010\\ \\qquad 1110100011101010010111111100101000011010011011011011101111010111000101111111001010101001100101111011 $$","title":"ii) Execute step 3 of the BB84 protocol to extract the key"},{"location":"cryptography/cryptography/#iii-decrypt-the-message-using-the-extracted-key","text":"The message encryption section in the introduction describes how to do so. You can check whether your decrypted message bit string is correct by check_decrypted(decrypted) . m = 0011011010100011101000001100010000001000011000101110110111100111111110001111100011100101011010111010111010001 \\ 1101010010111111100101000011010011011011011101111010111000101111111001010101001100101111011 # encrypted message decrypted = for i,t in enumerate (m): #print(i,t) im = ( int (t) + int (key[i % 50 ])) % 2 decrypted = decrypted + str (im) check_decrypted(decrypted) So far, so good \ud83c\udf89! You decrypted the message! Of course there is an actual message encoded in this bit string. To encode letters, Alice used Morse code (see here for more details: https://en.wikipedia.org/wiki/Morse_code). However, as she could only send zeros and ones and wanted to keep her message as short as possible, she encoded a dot (\"dit\") as '1' a dash (\"dah\") as '11' an intra-character gap (between each dot and dash within a character) as '0' a short gap (that separates letters) as '00' a medium gap (that separates words) as '000'. Here is an example:","title":"iii) Decrypt the message using the extracted key"},{"location":"cryptography/cryptography/#iv-try-to-decode-alices-message","text":"In a first step, convert the decrypted message from above into morse code. In a second step, use the provided dictionary to decode the morse code. Copy and paste the solution string on the IBM Quantum Challenge page to complete the exercise and track your progress. decrypted 10110100100110101001101010010100110010110101101011001101011010011011011001101100110101011010010110100110101011010011011001011001101011011001010101011001101101011001010110010110011010011001010110011011 MORSE_CODE_DICT = { a : .- , b : -... , c : -.-. , d : -.. , e : . , f : ..-. , g : --. , h : .... , i : .. , j : .--- , k : -.- , l : .-.. , m : -- , n : -. , o : --- , p : .--. , q : --.- , r : .-. , s : ... , t : - , u : ..- , v : ...- , w : .-- , x : -..- , y : -.-- , z : --.. , 1 : .---- , 2 : ..--- , 3 : ...-- , 4 : ....- , 5 : ..... , 6 : -.... , 7 : --... , 8 : ---.. , 9 : ----. , 0 : ----- , , : --..-- , . : .-.-.- , ? : ..--.. , / : -..-. , - : -....- , ( : -.--. , ) : -.--.- } MCODE = dec = decrypted while len (dec) 3 : if dec[ 0 ] == 1 and dec[ 0 : 2 ] != 11 : MCODE = MCODE + . dec = dec[ 1 :] if dec[ 0 : 2 ] == 11 and len (dec) 1 : MCODE = MCODE + - dec = dec[ 2 :] if dec[ 0 ] == 0 and dec[ 0 : 2 ] != 00 and dec[ 0 : 3 ] != 000 and len (dec) 3 : MCODE = MCODE + dec = dec[ 1 :] if dec[ 0 : 2 ] == 00 and dec[ 0 : 3 ] != 000 and len (dec) 3 : MCODE = MCODE + + # seperates letters dec = dec[ 2 :] if dec[ 0 : 3 ] == 000 and i len (dec) - 3 and len (dec) 3 : MCODE = MCODE + x # seperates words dec = dec[ 3 :] MCODE = MCODE + -- RDICT = {} for k,v in MORSE_CODE_DICT . items(): RDICT . update({v:k}) MID = MCODE . split( + ) solution = for item in MID: #print(RDICT[item]) solution = solution + RDICT[item] solution = solution[ 0 : - 1 ] + m show_message(solution) Congratulations \ud83c\udf89! Submit the following text reddit.com/r/may4quantum on the IBM Quantum Challenge page to see if you are correct.","title":"iv) Try to decode Alice's message!"},{"location":"gates/cnot/cnot/","text":"CNOT gate Multiqubit gate requires multiple qubit circuit. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy CNOT gate This gate is a conditional gate that performs an X-gate on the second qubit (target), if the state of the first qubit (control) is |1\u27e9 . qc = QuantumCircuit( 2 ) qc . cx( 0 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Let's see the matrix element of the CNOT gate. getMatrix(qc) matrix([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j], [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]) CNOT gate has two representation based on which qubit is target. $$\\text{CNOT} = \\left( \\begin{array}{cccc} 1 0 0 0 \\\\ 0 0 0 1 \\\\ 0 0 1 0 \\\\ 0 1 0 0 \\\\ \\end{array} \\right) , \\quad \\text{CNOT} = \\left( \\begin{array}{cccc} 1 0 0 0 \\\\ 0 1 0 0 \\\\ 0 0 0 1 \\\\ 0 0 1 0 \\\\ \\end{array} \\right)$$ SWAP gate What will happen if we apply 3 CNOT gates as shown below? qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . barrier() qc . cx( 0 , 1 ) qc . cx( 1 , 0 ) qc . cx( 0 , 1 ) qc . barrier() qc . h( 1 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-6.123234e-17j 0.+0.000000e+00j 0.+0.000000e+00j 0.+0.000000e+00j] In fact, these three CNOT gates are creating SWAP gate. Let's check. qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . barrier() qc . swap( 0 , 1 ) qc . barrier() qc . h( 1 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-6.123234e-17j 0.+0.000000e+00j 0.+0.000000e+00j 0.+0.000000e+00j] Circuit Identity |+ and |- state are Hadamard basis. Lets see the effect of this basis change. qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . h( 1 ) qc . barrier() qc . cx( 0 , 1 ) qc . barrier() qc . h( 0 ) qc . h( 1 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-1.2246468e-16j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j] The above circuit is equivalent to the following circuit. qc = QuantumCircuit( 2 ) qc . cx( 1 , 0 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.+0.j 0.+0.j 0.+0.j 0.+0.j] Toffoli Gate The Toffoli gate is a three-qubit gate with two controls and one target. It performs an X on the target only if both controls are in the state |1\u27e9. A Toffoli can also be thought of as a controlled-controlled-NOT, and is also called the CCX gate. qc = QuantumCircuit( 3 ) qc . ccx( 0 , 1 , 2 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-5.55111512e-17j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j] Lets see the matrix form of Tiffoli gate. getMatrix(qc) matrix([[1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])","title":"CNOT Gate"},{"location":"gates/cnot/cnot/#cnot-gate","text":"Multiqubit gate requires multiple qubit circuit. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy","title":"CNOT gate"},{"location":"gates/cnot/cnot/#cnot-gate_1","text":"This gate is a conditional gate that performs an X-gate on the second qubit (target), if the state of the first qubit (control) is |1\u27e9 . qc = QuantumCircuit( 2 ) qc . cx( 0 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Let's see the matrix element of the CNOT gate. getMatrix(qc) matrix([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j], [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]) CNOT gate has two representation based on which qubit is target. $$\\text{CNOT} = \\left( \\begin{array}{cccc} 1 0 0 0 \\\\ 0 0 0 1 \\\\ 0 0 1 0 \\\\ 0 1 0 0 \\\\ \\end{array} \\right) , \\quad \\text{CNOT} = \\left( \\begin{array}{cccc} 1 0 0 0 \\\\ 0 1 0 0 \\\\ 0 0 0 1 \\\\ 0 0 1 0 \\\\ \\end{array} \\right)$$","title":"CNOT gate"},{"location":"gates/cnot/cnot/#swap-gate","text":"What will happen if we apply 3 CNOT gates as shown below? qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . barrier() qc . cx( 0 , 1 ) qc . cx( 1 , 0 ) qc . cx( 0 , 1 ) qc . barrier() qc . h( 1 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-6.123234e-17j 0.+0.000000e+00j 0.+0.000000e+00j 0.+0.000000e+00j] In fact, these three CNOT gates are creating SWAP gate. Let's check. qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . barrier() qc . swap( 0 , 1 ) qc . barrier() qc . h( 1 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-6.123234e-17j 0.+0.000000e+00j 0.+0.000000e+00j 0.+0.000000e+00j]","title":"SWAP gate"},{"location":"gates/cnot/cnot/#circuit-identity","text":"|+ and |- state are Hadamard basis. Lets see the effect of this basis change. qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . h( 1 ) qc . barrier() qc . cx( 0 , 1 ) qc . barrier() qc . h( 0 ) qc . h( 1 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-1.2246468e-16j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j] The above circuit is equivalent to the following circuit. qc = QuantumCircuit( 2 ) qc . cx( 1 , 0 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.+0.j 0.+0.j 0.+0.j 0.+0.j]","title":"Circuit Identity"},{"location":"gates/cnot/cnot/#toffoli-gate","text":"The Toffoli gate is a three-qubit gate with two controls and one target. It performs an X on the target only if both controls are in the state |1\u27e9. A Toffoli can also be thought of as a controlled-controlled-NOT, and is also called the CCX gate. qc = QuantumCircuit( 3 ) qc . ccx( 0 , 1 , 2 ) print (getStateVector(qc)) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) [1.-5.55111512e-17j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j] Lets see the matrix form of Tiffoli gate. getMatrix(qc) matrix([[1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, 1.-0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])","title":"Toffoli Gate"},{"location":"gates/hgate/hgate/","text":"Hadamard Gate Hadamard gate superpose the quantum state uniformly. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import glob import moviepy.editor as mpy Hadamard Gate (1 qubit) qc = QuantumCircuit( 1 ) qc . h( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Single qubit state vector backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec1 = job . get_statevector(qc) vec1 array([0.70710678+0.j, 0.70710678+0.j]) getBlochSphere(qc) Single qubit Matrix representation backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) HM1 = np . matrix(ndArray) HM1 matrix([[ 0.707+0.j, 0.707-0.j], [ 0.707+0.j, -0.707+0.j]]) Hadamard Gate (2 qubits) Define circuit qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . h( 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) State vector (ket, phase and measurement) backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec2 = job . get_statevector(qc) vec2 array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j]) two qubit state vector as tensor product Since this circuit consists of pure superposition brought up by hadamard gate, it is possible to obtain final state vector by taking direct product of single qubit states. Results from operation of H gate on single qubit can be multiplied with direct product operation to get final state. $$ \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0 \\rangle + | 1\\rangle) = \\frac{1}{2}(|00 \\rangle + |01 \\rangle + |10 \\rangle + |11 \\rangle $$ i.e., $$\\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array} \\right) \\otimes \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array}\\right) = \\frac{1}{2}\\left( \\begin{array}{cc} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{array}\\right)$$ Where \\(|00 \\rangle , |01 \\rangle , |10 \\rangle \\) and \\( |11 \\rangle \\) are basis states for two qubit system. vec2 = np . kron(vec1,vec1) vec2 array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j]) Matrix Representation Based on above Bell circuit, lets construct the matrix representation of the circuit using fundamental gates matrices involved in the circuit. $$H = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 1 \\\\ 1 -1 \\end{array}\\right)$$ Matrix representation of above quantum circuit $$ U = H \\otimes H = \\left( \\begin{array}{cc} H H \\\\ H -H \\end{array} \\right)$$ backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) UM2 = np . matrix(ndArray) UM2 matrix([[ 0.5+0.j, 0.5-0.j, 0.5-0.j, 0.5-0.j], [ 0.5+0.j, -0.5+0.j, 0.5-0.j, -0.5+0.j], [ 0.5+0.j, 0.5-0.j, -0.5+0.j, -0.5+0.j], [ 0.5+0.j, -0.5+0.j, -0.5+0.j, 0.5-0.j]]) H = 1 / np . sqrt( 2 ) * np . array([[ 1 , 1 ],[ 1 , - 1 ]]) U = np . kron(H,H) print (U) [[ 0.5 0.5 0.5 0.5] [ 0.5 -0.5 0.5 -0.5] [ 0.5 0.5 -0.5 -0.5] [ 0.5 -0.5 -0.5 0.5]] Exercise: Hadamard Gate (3 qubits) Consider a 3 qubits quantum circuit with H gate applied to each qubit. qc = QuantumCircuit( 3 ) for k in range ( 3 ): qc . h(k) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) \\(\\textbf{Exercise:}\\) Using above quantum circuit, find final state vector in ket notation, phase plot and measurement simulation histogram. \\( \\textbf{Exercise:}\\) Using above circuit, find final state vector by implementing tensor product of three single qubit states. \\( \\textbf{Hint}\\): \\(| \\psi \\rangle = \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\) \\( \\textbf{Exercise:}\\) Using above circuit, find matrix representation of the quantum circuit by implementing tensor product of fundamental gate matrices. \\( \\textbf{Hint} : U = H \\otimes H \\otimes H \\) A fun Experiment qc = QuantumCircuit( 2 ) for i in range ( 10 ): if i 1 and i % 2 == 0 : qc . barrier() qc . h( 0 ) qc . h( 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Get Bloch Get Phase","title":"Hadamard Gate"},{"location":"gates/hgate/hgate/#hadamard-gate","text":"Hadamard gate superpose the quantum state uniformly. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import glob import moviepy.editor as mpy","title":"Hadamard Gate"},{"location":"gates/hgate/hgate/#hadamard-gate-1-qubit","text":"qc = QuantumCircuit( 1 ) qc . h( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Single qubit state vector backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec1 = job . get_statevector(qc) vec1 array([0.70710678+0.j, 0.70710678+0.j]) getBlochSphere(qc) Single qubit Matrix representation backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) HM1 = np . matrix(ndArray) HM1 matrix([[ 0.707+0.j, 0.707-0.j], [ 0.707+0.j, -0.707+0.j]])","title":"Hadamard Gate (1 qubit)"},{"location":"gates/hgate/hgate/#hadamard-gate-2-qubits","text":"Define circuit qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . h( 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) State vector (ket, phase and measurement) backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec2 = job . get_statevector(qc) vec2 array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j]) two qubit state vector as tensor product Since this circuit consists of pure superposition brought up by hadamard gate, it is possible to obtain final state vector by taking direct product of single qubit states. Results from operation of H gate on single qubit can be multiplied with direct product operation to get final state. $$ \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0 \\rangle + | 1\\rangle) = \\frac{1}{2}(|00 \\rangle + |01 \\rangle + |10 \\rangle + |11 \\rangle $$ i.e., $$\\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array} \\right) \\otimes \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 \\\\ 1 \\end{array}\\right) = \\frac{1}{2}\\left( \\begin{array}{cc} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{array}\\right)$$ Where \\(|00 \\rangle , |01 \\rangle , |10 \\rangle \\) and \\( |11 \\rangle \\) are basis states for two qubit system. vec2 = np . kron(vec1,vec1) vec2 array([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j]) Matrix Representation Based on above Bell circuit, lets construct the matrix representation of the circuit using fundamental gates matrices involved in the circuit. $$H = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 1 \\\\ 1 -1 \\end{array}\\right)$$ Matrix representation of above quantum circuit $$ U = H \\otimes H = \\left( \\begin{array}{cc} H H \\\\ H -H \\end{array} \\right)$$ backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) UM2 = np . matrix(ndArray) UM2 matrix([[ 0.5+0.j, 0.5-0.j, 0.5-0.j, 0.5-0.j], [ 0.5+0.j, -0.5+0.j, 0.5-0.j, -0.5+0.j], [ 0.5+0.j, 0.5-0.j, -0.5+0.j, -0.5+0.j], [ 0.5+0.j, -0.5+0.j, -0.5+0.j, 0.5-0.j]]) H = 1 / np . sqrt( 2 ) * np . array([[ 1 , 1 ],[ 1 , - 1 ]]) U = np . kron(H,H) print (U) [[ 0.5 0.5 0.5 0.5] [ 0.5 -0.5 0.5 -0.5] [ 0.5 0.5 -0.5 -0.5] [ 0.5 -0.5 -0.5 0.5]] Exercise: Hadamard Gate (3 qubits) Consider a 3 qubits quantum circuit with H gate applied to each qubit. qc = QuantumCircuit( 3 ) for k in range ( 3 ): qc . h(k) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) \\(\\textbf{Exercise:}\\) Using above quantum circuit, find final state vector in ket notation, phase plot and measurement simulation histogram. \\( \\textbf{Exercise:}\\) Using above circuit, find final state vector by implementing tensor product of three single qubit states. \\( \\textbf{Hint}\\): \\(| \\psi \\rangle = \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\otimes \\frac{1}{\\sqrt{2}} (|0 \\rangle + | 1\\rangle) \\) \\( \\textbf{Exercise:}\\) Using above circuit, find matrix representation of the quantum circuit by implementing tensor product of fundamental gate matrices. \\( \\textbf{Hint} : U = H \\otimes H \\otimes H \\)","title":"Hadamard Gate (2 qubits)"},{"location":"gates/hgate/hgate/#a-fun-experiment","text":"qc = QuantumCircuit( 2 ) for i in range ( 10 ): if i 1 and i % 2 == 0 : qc . barrier() qc . h( 0 ) qc . h( 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Get Bloch Get Phase","title":"A fun Experiment"},{"location":"gates/pauli/pauli/","text":"Pauli-gates Pauli Gates ase based on Pauli matrices. These are special matrices; both Hermitian and Unitary. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy Pauli Gates are represented by \\( X, Y, Z \\)and their matrix form are: $$ X = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 0 1 \\\\ 1 0 \\end{array} \\right); Y = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 0 -i \\\\ i 0 \\end{array} \\right); Z = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 0 \\\\ 0 -1 \\end{array} \\right)$$ Lets see what happens to the qubit by application of these gates X-Gate X gate takes \\( |0 \\rangle\\) to \\( |1 \\rangle \\) and vise versa. This gate rotates the qubit by \\(\\pi \\) angle around X axis. qc = QuantumCircuit( 1 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [0.+0.j 1.+0.j] Which vector will be unaffected by this rotation? A vector pointing along x-axis remains unaffected. We can show this by creating a qubit pointing in x-axis by application of H gate and apply x gate qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [0.70710678+0.j 0.70710678+0.j] qc = QuantumCircuit( 1 ) qc . x( 0 ) qc . h( 0 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) In fact, you discovered the eigen vector of X operator. These are represented as: $$|+\\rangle = \\tfrac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) = \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\ 1 \\end{bmatrix}$$ $$|-\\rangle = \\tfrac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle) = \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\ -1 \\end{bmatrix}$$ Y-Gate This gate rotates the qubit around Y axis by $\\pi$ angle. qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . y( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j] Which vector will be unaffected by this rotation? A vector pointing along y-axis remains unaffected. We can show this by creating a qubit pointing in x-axis by application of H gate and rotate it to the direction og y-axis and apply Y gate. qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . u3( 0 , 0 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [7.07106781e-01+0.j 2.00307049e-16+0.70710678j] qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . u3( 0 , 0 ,np . pi / 2 , 0 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [7.07106781e-01+0.j 2.00307049e-16-0.70710678j] In fact, you discovered the eigen vector of Y operator. These are represented as: $$|\\circlearrowright\\rangle = \\frac{1}{\\sqrt{2}}\\left(|0\\rangle + i|1\\rangle\\right)$$. $$|\\circlearrowleft\\rangle = \\frac{1}{\\sqrt{2}}\\left(|0\\rangle - i|1\\rangle\\right)$$. Z-gate This gate rotates the qubit around Z axis by $\\pi$ angle. qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . z( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j] Which vector will be unaffected by this rotation? A vector pointing along z-axis remains unaffected. This is the initial value of qubit which is very easy to verify. qc = QuantumCircuit( 1 ) qc . z( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [1.+0.j 0.+0.j] Similarly, you discovered the eigen vector of Z operator. These are represented as: $$|0 \\rangle = \\frac{1}{\\sqrt{2}}\\left(| + \\rangle + |- \\rangle\\right) $$. $$|1 \\rangle = \\frac{1}{\\sqrt{2}}\\left(|+ \\rangle + |- \\rangle\\right) $$ Multiple Pauli Gates qc = QuantumCircuit( 3 ) qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . barrier() qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . barrier() style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [1.-2.4492936e-16j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j] Making Fun Lets apply H gate to each qubit in 3 qubits system and then apply X,Y,and Z gate respectively. This operation followed by total 2 $\\pi$ roatation and another set of Pauli gates and H gates brings the qubit to original position. qc = QuantumCircuit( 3 ) qc . h( 0 ) qc . h( 1 ) qc . h( 2 ) qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . barrier() for i in range ( 8 ): qc . u3( 0 , 0 ,np . pi / 4 , 0 ) qc . u3(np . pi / 4 , 0 , 0 , 1 ) qc . u3( 0 ,np . pi / 4 , 0 , 2 ) qc . barrier() qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . h( 0 ) qc . h( 1 ) qc . h( 2 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Lets see where are our individual qubits, finally! print (getStateVector(qc)) getBlochSphere(qc) [1.-8.41170949e-17j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j] Lets see what actually happens to each qubit in the intermediate steps: We can also visualize the 8 complex cofficients for the state vector in the intermediate steps","title":"Pauli Gate"},{"location":"gates/pauli/pauli/#pauli-gates","text":"Pauli Gates ase based on Pauli matrices. These are special matrices; both Hermitian and Unitary. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy Pauli Gates are represented by \\( X, Y, Z \\)and their matrix form are: $$ X = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 0 1 \\\\ 1 0 \\end{array} \\right); Y = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 0 -i \\\\ i 0 \\end{array} \\right); Z = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 0 \\\\ 0 -1 \\end{array} \\right)$$ Lets see what happens to the qubit by application of these gates","title":"Pauli-gates"},{"location":"gates/pauli/pauli/#x-gate","text":"X gate takes \\( |0 \\rangle\\) to \\( |1 \\rangle \\) and vise versa. This gate rotates the qubit by \\(\\pi \\) angle around X axis. qc = QuantumCircuit( 1 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [0.+0.j 1.+0.j] Which vector will be unaffected by this rotation? A vector pointing along x-axis remains unaffected. We can show this by creating a qubit pointing in x-axis by application of H gate and apply x gate qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [0.70710678+0.j 0.70710678+0.j] qc = QuantumCircuit( 1 ) qc . x( 0 ) qc . h( 0 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) In fact, you discovered the eigen vector of X operator. These are represented as: $$|+\\rangle = \\tfrac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) = \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\ 1 \\end{bmatrix}$$ $$|-\\rangle = \\tfrac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle) = \\tfrac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\ -1 \\end{bmatrix}$$","title":"X-Gate"},{"location":"gates/pauli/pauli/#y-gate","text":"This gate rotates the qubit around Y axis by $\\pi$ angle. qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . y( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j] Which vector will be unaffected by this rotation? A vector pointing along y-axis remains unaffected. We can show this by creating a qubit pointing in x-axis by application of H gate and rotate it to the direction og y-axis and apply Y gate. qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . u3( 0 , 0 ,np . pi / 2 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [7.07106781e-01+0.j 2.00307049e-16+0.70710678j] qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . u3( 0 , 0 ,np . pi / 2 , 0 ) qc . x( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [7.07106781e-01+0.j 2.00307049e-16-0.70710678j] In fact, you discovered the eigen vector of Y operator. These are represented as: $$|\\circlearrowright\\rangle = \\frac{1}{\\sqrt{2}}\\left(|0\\rangle + i|1\\rangle\\right)$$. $$|\\circlearrowleft\\rangle = \\frac{1}{\\sqrt{2}}\\left(|0\\rangle - i|1\\rangle\\right)$$.","title":"Y-Gate"},{"location":"gates/pauli/pauli/#z-gate","text":"This gate rotates the qubit around Z axis by $\\pi$ angle. qc = QuantumCircuit( 1 ) qc . h( 0 ) qc . z( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j] Which vector will be unaffected by this rotation? A vector pointing along z-axis remains unaffected. This is the initial value of qubit which is very easy to verify. qc = QuantumCircuit( 1 ) qc . z( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [1.+0.j 0.+0.j] Similarly, you discovered the eigen vector of Z operator. These are represented as: $$|0 \\rangle = \\frac{1}{\\sqrt{2}}\\left(| + \\rangle + |- \\rangle\\right) $$. $$|1 \\rangle = \\frac{1}{\\sqrt{2}}\\left(|+ \\rangle + |- \\rangle\\right) $$","title":"Z-gate"},{"location":"gates/pauli/pauli/#multiple-pauli-gates","text":"qc = QuantumCircuit( 3 ) qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . barrier() qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . barrier() style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [1.-2.4492936e-16j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j 0.+0.0000000e+00j]","title":"Multiple Pauli Gates"},{"location":"gates/pauli/pauli/#making-fun","text":"Lets apply H gate to each qubit in 3 qubits system and then apply X,Y,and Z gate respectively. This operation followed by total 2 $\\pi$ roatation and another set of Pauli gates and H gates brings the qubit to original position. qc = QuantumCircuit( 3 ) qc . h( 0 ) qc . h( 1 ) qc . h( 2 ) qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . barrier() for i in range ( 8 ): qc . u3( 0 , 0 ,np . pi / 4 , 0 ) qc . u3(np . pi / 4 , 0 , 0 , 1 ) qc . u3( 0 ,np . pi / 4 , 0 , 2 ) qc . barrier() qc . x( 0 ) qc . y( 1 ) qc . z( 2 ) qc . h( 0 ) qc . h( 1 ) qc . h( 2 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Lets see where are our individual qubits, finally! print (getStateVector(qc)) getBlochSphere(qc) [1.-8.41170949e-17j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j] Lets see what actually happens to each qubit in the intermediate steps: We can also visualize the 8 complex cofficients for the state vector in the intermediate steps","title":"Making Fun"},{"location":"gates/rphi/rphi/","text":"R-phi Gate The R\u03d5-gate performs a rotation of \ud835\udf19 around the Z-axis. It has the matrix: $$ R_\\phi = \\begin{bmatrix} 1 & 0 \\\\ 0 & e^{i\\phi} \\end{bmatrix}$$ % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy R-Phi (1 qubit) qc1 = QuantumCircuit( 1 ) qc1 . rz(np . pi / 4 , 0 ) style = { backgroundcolor : lavender } qc1 . draw(output = mpl , style = style) getStateVector(qc1) array([1.+0.j, 0.+0.j]) getBlochSphere(qc1) R-phi (2 qubits) qc2 = QuantumCircuit( 2 ) qc2 . rz(np . pi / 4 , 0 ) qc2 . rz(np . pi / 4 , 1 ) style = { backgroundcolor : lavender } qc2 . draw(output = mpl , style = style) Fun Experiment (1 qubit) qc_e1 = QuantumCircuit( 1 ) qc_e1 . h( 0 ) qc_e1 . barrier() for i in range ( 10 ): qc_e1 . rz(np . pi / 5 , 0 ) qc_e1 . barrier() qc_e1 . h( 0 ) style = { backgroundcolor : lavender } qc_e1 . draw(output = mpl , style = style) Get Bloch Get Phase Fun Experiment (2 qubits) qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . u3(np . pi / 4 ,np . pi / 4 , 0 , 1 ) qc . barrier() for i in range ( 8 ): qc . rz(np . pi / 4 , 0 ) qc . rz(np . pi / 4 , 1 ) qc . barrier() qc . h( 0 ) qc . u3( - np . pi / 4 , - np . pi / 4 , 0 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Get Bloch Get Phase Special R-phi Gates: \\( R_{\\phi}\\) gate is reprisented by \\(S\\) gate when \\( \\phi = \\pi/2 \\). It is also called \\( \\sqrt{Z} \\) gate. $$ S = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{\\frac{i\\pi}{2}} \\end{array}\\right), \\quad S^\\dagger = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{-\\frac{i\\pi}{2}} \\end{array}\\right) $$ \\( R_{\\phi} \\) gate is reprisented by \\( T \\) gate when \\( \\phi = \\pi/4 \\). $$T = \\left( \\begin{array} 1 0 \\\\ 0 e^{\\frac{i\\pi}{4}} \\end{array}\\right), \\quad T^\\dagger = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{-\\frac{i\\pi}{4}} \\end{array}\\right)$$","title":"R-Phi Gate"},{"location":"gates/rphi/rphi/#r-phi-gate","text":"The R\u03d5-gate performs a rotation of \ud835\udf19 around the Z-axis. It has the matrix: $$ R_\\phi = \\begin{bmatrix} 1 & 0 \\\\ 0 & e^{i\\phi} \\end{bmatrix}$$ % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy","title":"R-phi Gate"},{"location":"gates/rphi/rphi/#r-phi-1-qubit","text":"qc1 = QuantumCircuit( 1 ) qc1 . rz(np . pi / 4 , 0 ) style = { backgroundcolor : lavender } qc1 . draw(output = mpl , style = style) getStateVector(qc1) array([1.+0.j, 0.+0.j]) getBlochSphere(qc1)","title":"R-Phi (1 qubit)"},{"location":"gates/rphi/rphi/#r-phi-2-qubits","text":"qc2 = QuantumCircuit( 2 ) qc2 . rz(np . pi / 4 , 0 ) qc2 . rz(np . pi / 4 , 1 ) style = { backgroundcolor : lavender } qc2 . draw(output = mpl , style = style)","title":"R-phi (2 qubits)"},{"location":"gates/rphi/rphi/#fun-experiment-1-qubit","text":"qc_e1 = QuantumCircuit( 1 ) qc_e1 . h( 0 ) qc_e1 . barrier() for i in range ( 10 ): qc_e1 . rz(np . pi / 5 , 0 ) qc_e1 . barrier() qc_e1 . h( 0 ) style = { backgroundcolor : lavender } qc_e1 . draw(output = mpl , style = style) Get Bloch Get Phase","title":"Fun Experiment (1 qubit)"},{"location":"gates/rphi/rphi/#fun-experiment-2-qubits","text":"qc = QuantumCircuit( 2 ) qc . h( 0 ) qc . u3(np . pi / 4 ,np . pi / 4 , 0 , 1 ) qc . barrier() for i in range ( 8 ): qc . rz(np . pi / 4 , 0 ) qc . rz(np . pi / 4 , 1 ) qc . barrier() qc . h( 0 ) qc . u3( - np . pi / 4 , - np . pi / 4 , 0 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Get Bloch Get Phase","title":"Fun Experiment (2 qubits)"},{"location":"gates/rphi/rphi/#special-r-phi-gates","text":"\\( R_{\\phi}\\) gate is reprisented by \\(S\\) gate when \\( \\phi = \\pi/2 \\). It is also called \\( \\sqrt{Z} \\) gate. $$ S = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{\\frac{i\\pi}{2}} \\end{array}\\right), \\quad S^\\dagger = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{-\\frac{i\\pi}{2}} \\end{array}\\right) $$ \\( R_{\\phi} \\) gate is reprisented by \\( T \\) gate when \\( \\phi = \\pi/4 \\). $$T = \\left( \\begin{array} 1 0 \\\\ 0 e^{\\frac{i\\pi}{4}} \\end{array}\\right), \\quad T^\\dagger = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{-\\frac{i\\pi}{4}} \\end{array}\\right)$$","title":"Special R-phi Gates:"},{"location":"gates/ugate/ugate/","text":"U-gates The U 3 -gate is the most general of all single-qubit quantum gates. It is a parametrised gate of the form: $$ U_3(\\theta, \\phi, \\lambda) = \\left( \\begin{array}{cc} \\cos(\\theta/2) -e^{i\\lambda}\\sin(\\theta/2) \\\\ e^{i\\phi}\\sin(\\theta/2) e^{i\\lambda+i\\phi}\\cos(\\theta/2) \\end{array}\\right) $$ Qiskit provides U 2 and U 1 -gates, which are specific cases of the U 3 gate in which \\( \\theta = \\tfrac{\\pi}{2} \\), and \\( \\theta = \\phi = 0 \\) respectively. You will notice that the U 1 -gate is equivalent to the R \u03d5 -gate. $$U_3(\\tfrac{\\pi}{2}, \\phi, \\lambda) = U_2 = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 -e^{i\\lambda} \\\\ e^{i\\phi} e^{i\\lambda+i\\phi} \\end{array}\\right);$$ $$ U_3(0, 0, \\lambda) = U_1 = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{i \\lambda} \\end{array} \\right) $$ \\(R_x,R_y, R_z\\) gates are special case of $U_3$ gate. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy U Gate (1 qubit) Lets apply \\( \\theta = \\pi/3, \\phi = pi/3 , \\lambda = pi/3 \\) to a single qubit through \\(U_3\\) gate. We can se the rotation in bloch sphere. qc = QuantumCircuit( 1 ) qc . u3(np . pi / 3 ,np . pi / 3 ,np . pi / 3 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Single qubit state vector backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec1 = job . get_statevector(qc) vec1 array([0.8660254+0.j , 0.25 +0.4330127j]) getBlochSphere(qc) Matrix backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) UM1 = np . matrix(ndArray) UM1 matrix([[ 0.866+0.j , -0.25 -0.433j], [ 0.25 +0.433j, -0.433+0.75j ]]) U Gate (2 qubits) Define circuit qc = QuantumCircuit( 2 ) qc . u3(np . pi / 3 ,np . pi / 3 ,np . pi / 3 , 0 ) qc . u3(np . pi / 3 ,np . pi / 3 ,np . pi / 3 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) State vector Lets perform some manual approach for final state in ket notation. backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec2 = job . get_statevector(qc) vec2 array([ 0.75 +0.j , 0.21650635+0.375j , 0.21650635+0.375j , -0.125 +0.21650635j]) getBlochSphere(qc) Two qubits state vector as tensor product Since this circuit consists of pure superposition brought up by $U_3$ gate, it is possible to obtain final state vector by taking direct product of single qubit states. Results from operation of $U_3$ gate on single qubit can be multiplied with direct product operation to get final state. $$ (a|0 \\rangle + b| 1\\rangle) \\otimes (c|0 \\rangle + d| 1\\rangle) = (ac|00 \\rangle + ad|01 \\rangle + bc|10 \\rangle + bd|11 \\rangle $$ i.e., $$\\left(\\begin{array}{c} a \\\\ b \\end{array} \\right) \\otimes \\left( \\begin{array}{c} c \\\\ d \\end{array} \\right) = \\left( \\begin{array}{c} ac \\\\ ad \\\\ bc \\\\ bd \\end{array} \\right)$$ Where \\( |00 \\rangle , |01 \\rangle , |10 \\rangle \\) and \\( |11 \\rangle \\) are basis states for two qubit system. vec2 = np . kron(vec1,vec1) vec2 array([ 0.75 +0.j , 0.21650635+0.375j , 0.21650635+0.375j , -0.125 +0.21650635j]) Matrix Representation Based on above circuit, lets construct the matrix representation of the circuit using fundamental gates matrices involved in the circuit. $$ U_3(\\theta_1, \\phi_1, \\lambda_1) = \\left( \\begin{array}{cc} \\cos(\\theta/2) -e^{i\\lambda}\\sin(\\theta/2) \\\\ e^{i\\phi}\\sin(\\theta/2) e^{i\\lambda+i\\phi}\\cos(\\theta/2) \\end{array} \\right)$$ Final Matrix to represent the quantum circuit $$ U = U_3 \\otimes U_3$$ backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) UM2 = np . matrix(ndArray) UM2 matrix([[ 0.75 +0.j , -0.217-0.375j, -0.217-0.375j, -0.125+0.217j], [ 0.217+0.375j, -0.375+0.65j , 0.125-0.217j, 0.433-0.j ], [ 0.217+0.375j, 0.125-0.217j, -0.375+0.65j , 0.433-0.j ], [-0.125+0.217j, -0.433+0.j , -0.433+0.j , -0.375-0.65j ]]) UM2_from_UM1 = np . kron(UM1,UM1) UM2_from_UM1 matrix([[ 0.749956+0.00000e+00j, -0.2165 -3.74978e-01j, -0.2165 -3.74978e-01j, -0.124989+2.16500e-01j], [ 0.2165 +3.74978e-01j, -0.374978+6.49500e-01j, 0.124989-2.16500e-01j, 0.433 -1.10000e-05j], [ 0.2165 +3.74978e-01j, 0.124989-2.16500e-01j, -0.374978+6.49500e-01j, 0.433 -1.10000e-05j], [-0.124989+2.16500e-01j, -0.433 +1.10000e-05j, -0.433 +1.10000e-05j, -0.375011-6.49500e-01j]]) Exercise: \\( U_3 \\) Gate (3 qubits) Consider a 3 qubits quantum circuit with H gate applied to each qubit. n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) for k in range ( 3 ): qc . h(q[k]) qc . barrier() qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) $$\\textbf{Exercise:}$$ Using above quantum circuit, find final state vector in ket notation, bloch sphere plot for each qubits. $$\\textbf{Exercise:}$$ Using above circuit, find final state vector by implementing tensor product of three single qubit states. \\( \\textbf{Hint} \\): \\(| \\psi \\rangle = (a|0 \\rangle + b| 1\\rangle) \\otimes (c|0 \\rangle + d| 1\\rangle) \\otimes (e|0 \\rangle + f| 1\\rangle) \\) $$\\textbf{Exercise:}$$ Using above circuit, find matrix representation of the quantum circuit by implementing tensor product of fundamental gate matrices. \\( \\textbf{Hint} : U = U_3 \\otimes U_3 \\otimes U_3 \\) A fun Experiment qc = QuantumCircuit( 2 ) for i in range ( 10 ): qc . u3(np . pi / 3 ,np . pi / 6 ,np . pi / 4 , 0 ) qc . u3(np . pi / 6 ,np . pi / 4 ,np . pi / 3 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Get Bloch Get Phase","title":"Rotation Gate"},{"location":"gates/ugate/ugate/#u-gates","text":"The U 3 -gate is the most general of all single-qubit quantum gates. It is a parametrised gate of the form: $$ U_3(\\theta, \\phi, \\lambda) = \\left( \\begin{array}{cc} \\cos(\\theta/2) -e^{i\\lambda}\\sin(\\theta/2) \\\\ e^{i\\phi}\\sin(\\theta/2) e^{i\\lambda+i\\phi}\\cos(\\theta/2) \\end{array}\\right) $$ Qiskit provides U 2 and U 1 -gates, which are specific cases of the U 3 gate in which \\( \\theta = \\tfrac{\\pi}{2} \\), and \\( \\theta = \\phi = 0 \\) respectively. You will notice that the U 1 -gate is equivalent to the R \u03d5 -gate. $$U_3(\\tfrac{\\pi}{2}, \\phi, \\lambda) = U_2 = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 -e^{i\\lambda} \\\\ e^{i\\phi} e^{i\\lambda+i\\phi} \\end{array}\\right);$$ $$ U_3(0, 0, \\lambda) = U_1 = \\left( \\begin{array}{cc} 1 0 \\\\ 0 e^{i \\lambda} \\end{array} \\right) $$ \\(R_x,R_y, R_z\\) gates are special case of $U_3$ gate. % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy","title":"U-gates"},{"location":"gates/ugate/ugate/#u-gate-1-qubit","text":"Lets apply \\( \\theta = \\pi/3, \\phi = pi/3 , \\lambda = pi/3 \\) to a single qubit through \\(U_3\\) gate. We can se the rotation in bloch sphere. qc = QuantumCircuit( 1 ) qc . u3(np . pi / 3 ,np . pi / 3 ,np . pi / 3 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Single qubit state vector backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec1 = job . get_statevector(qc) vec1 array([0.8660254+0.j , 0.25 +0.4330127j]) getBlochSphere(qc) Matrix backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) UM1 = np . matrix(ndArray) UM1 matrix([[ 0.866+0.j , -0.25 -0.433j], [ 0.25 +0.433j, -0.433+0.75j ]])","title":"U Gate (1 qubit)"},{"location":"gates/ugate/ugate/#u-gate-2-qubits","text":"Define circuit qc = QuantumCircuit( 2 ) qc . u3(np . pi / 3 ,np . pi / 3 ,np . pi / 3 , 0 ) qc . u3(np . pi / 3 ,np . pi / 3 ,np . pi / 3 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) State vector Lets perform some manual approach for final state in ket notation. backend = BasicAer . get_backend( statevector_simulator ) job = execute(qc,backend) . result() vec2 = job . get_statevector(qc) vec2 array([ 0.75 +0.j , 0.21650635+0.375j , 0.21650635+0.375j , -0.125 +0.21650635j]) getBlochSphere(qc) Two qubits state vector as tensor product Since this circuit consists of pure superposition brought up by $U_3$ gate, it is possible to obtain final state vector by taking direct product of single qubit states. Results from operation of $U_3$ gate on single qubit can be multiplied with direct product operation to get final state. $$ (a|0 \\rangle + b| 1\\rangle) \\otimes (c|0 \\rangle + d| 1\\rangle) = (ac|00 \\rangle + ad|01 \\rangle + bc|10 \\rangle + bd|11 \\rangle $$ i.e., $$\\left(\\begin{array}{c} a \\\\ b \\end{array} \\right) \\otimes \\left( \\begin{array}{c} c \\\\ d \\end{array} \\right) = \\left( \\begin{array}{c} ac \\\\ ad \\\\ bc \\\\ bd \\end{array} \\right)$$ Where \\( |00 \\rangle , |01 \\rangle , |10 \\rangle \\) and \\( |11 \\rangle \\) are basis states for two qubit system. vec2 = np . kron(vec1,vec1) vec2 array([ 0.75 +0.j , 0.21650635+0.375j , 0.21650635+0.375j , -0.125 +0.21650635j]) Matrix Representation Based on above circuit, lets construct the matrix representation of the circuit using fundamental gates matrices involved in the circuit. $$ U_3(\\theta_1, \\phi_1, \\lambda_1) = \\left( \\begin{array}{cc} \\cos(\\theta/2) -e^{i\\lambda}\\sin(\\theta/2) \\\\ e^{i\\phi}\\sin(\\theta/2) e^{i\\lambda+i\\phi}\\cos(\\theta/2) \\end{array} \\right)$$ Final Matrix to represent the quantum circuit $$ U = U_3 \\otimes U_3$$ backend = BasicAer . get_backend( unitary_simulator ) job = execute(qc, backend) ndArray = job . result() . get_unitary(qc, decimals = 3 ) UM2 = np . matrix(ndArray) UM2 matrix([[ 0.75 +0.j , -0.217-0.375j, -0.217-0.375j, -0.125+0.217j], [ 0.217+0.375j, -0.375+0.65j , 0.125-0.217j, 0.433-0.j ], [ 0.217+0.375j, 0.125-0.217j, -0.375+0.65j , 0.433-0.j ], [-0.125+0.217j, -0.433+0.j , -0.433+0.j , -0.375-0.65j ]]) UM2_from_UM1 = np . kron(UM1,UM1) UM2_from_UM1 matrix([[ 0.749956+0.00000e+00j, -0.2165 -3.74978e-01j, -0.2165 -3.74978e-01j, -0.124989+2.16500e-01j], [ 0.2165 +3.74978e-01j, -0.374978+6.49500e-01j, 0.124989-2.16500e-01j, 0.433 -1.10000e-05j], [ 0.2165 +3.74978e-01j, 0.124989-2.16500e-01j, -0.374978+6.49500e-01j, 0.433 -1.10000e-05j], [-0.124989+2.16500e-01j, -0.433 +1.10000e-05j, -0.433 +1.10000e-05j, -0.375011-6.49500e-01j]]) Exercise: \\( U_3 \\) Gate (3 qubits) Consider a 3 qubits quantum circuit with H gate applied to each qubit. n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) qc = QuantumCircuit(q,c) for k in range ( 3 ): qc . h(q[k]) qc . barrier() qc . measure(q,c) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) $$\\textbf{Exercise:}$$ Using above quantum circuit, find final state vector in ket notation, bloch sphere plot for each qubits. $$\\textbf{Exercise:}$$ Using above circuit, find final state vector by implementing tensor product of three single qubit states. \\( \\textbf{Hint} \\): \\(| \\psi \\rangle = (a|0 \\rangle + b| 1\\rangle) \\otimes (c|0 \\rangle + d| 1\\rangle) \\otimes (e|0 \\rangle + f| 1\\rangle) \\) $$\\textbf{Exercise:}$$ Using above circuit, find matrix representation of the quantum circuit by implementing tensor product of fundamental gate matrices. \\( \\textbf{Hint} : U = U_3 \\otimes U_3 \\otimes U_3 \\)","title":"U Gate (2 qubits)"},{"location":"gates/ugate/ugate/#a-fun-experiment","text":"qc = QuantumCircuit( 2 ) for i in range ( 10 ): qc . u3(np . pi / 3 ,np . pi / 6 ,np . pi / 4 , 0 ) qc . u3(np . pi / 6 ,np . pi / 4 ,np . pi / 3 , 1 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Get Bloch Get Phase","title":"A fun Experiment"},{"location":"qubit/qubit/","text":"Qubit % matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit,ClassicalRegister,QuantumRegister from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy What is Qubit? A single qubit is represented by $$ |\\psi \\rangle = \\alpha |0\\rangle + \\beta|1\\rangle$$ Or, $$\\vert\\psi\\rangle = \\sqrt{1-p}\\vert0\\rangle + e^{i \\phi} \\sqrt{p} \\vert1\\rangle$$ Bloch Sphere Lets start to make fun with single qubit operation. A quantum circuit with single qubit can be created with following code. qc = QuantumCircuit( 1 ) This circuit initiate qubit at \\( |0 \\rangle \\) state. This qubit can be represented by a Bloch sphere as shown below. Lets print the vector representing this qubit and Plot the Bloch sphere. print (getStateVector(qc)) getBlochSphere(qc) [1.+0.j 0.+0.j] Lets apply Hadamard gate. It will rotate the qubit form \\(|0\\rangle\\) state to the direction of X-axix. i.e. \\( \\frac{1}{2}(|0 \\rangle + | 1 \\rangle)\\). We can also see the corresponding circuit diagram. qc . h( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Lets print the vector representing this qubit and plot the Bloch sphere. print (getStateVector(qc)) getBlochSphere(qc) [0.70710678+0.j 0.70710678+0.j] Now, our qubit is along the direction of X-axis. Lets try to rotate it about z-axis with \\( \\frac{\\pi}{4} \\) angle. qc . u3( 0 , 0 ,np . pi / 4 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [0.70710678+0.j 0.5 +0.5j] Now, you got the idea! Lets rotate to complete \\( 2\\pi \\) rotation by adding 7 more u3 gates and return this qubit back to it's initial position by acting final H gate. for i in range ( 7 ): qc . u3( 0 , 0 ,np . pi / 4 , 0 ) qc . h( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [1.+0.j 0.+0.j] Yahoo....! Now, qubit is back to original position. This can be shown in animation below. What happens to the two complex cofficient of the qubit as it passes through the sequence of these gates? We can calculate individual phase angle and magnitude of the complex cofficient and visualize them as shown below.","title":"Qubit"},{"location":"qubit/qubit/#qubit","text":"% matplotlib inline import numpy as np import IPython import matplotlib.pyplot as plt from qiskit import QuantumCircuit,ClassicalRegister,QuantumRegister from qiskit import BasicAer from qiskit.tools.jupyter import * from qiskit.visualization import * import seaborn as sns sns . set() from helper import * import os import glob import moviepy.editor as mpy","title":"Qubit"},{"location":"qubit/qubit/#what-is-qubit","text":"A single qubit is represented by $$ |\\psi \\rangle = \\alpha |0\\rangle + \\beta|1\\rangle$$ Or, $$\\vert\\psi\\rangle = \\sqrt{1-p}\\vert0\\rangle + e^{i \\phi} \\sqrt{p} \\vert1\\rangle$$","title":"What is Qubit?"},{"location":"qubit/qubit/#bloch-sphere","text":"Lets start to make fun with single qubit operation. A quantum circuit with single qubit can be created with following code. qc = QuantumCircuit( 1 ) This circuit initiate qubit at \\( |0 \\rangle \\) state. This qubit can be represented by a Bloch sphere as shown below. Lets print the vector representing this qubit and Plot the Bloch sphere. print (getStateVector(qc)) getBlochSphere(qc) [1.+0.j 0.+0.j] Lets apply Hadamard gate. It will rotate the qubit form \\(|0\\rangle\\) state to the direction of X-axix. i.e. \\( \\frac{1}{2}(|0 \\rangle + | 1 \\rangle)\\). We can also see the corresponding circuit diagram. qc . h( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) Lets print the vector representing this qubit and plot the Bloch sphere. print (getStateVector(qc)) getBlochSphere(qc) [0.70710678+0.j 0.70710678+0.j] Now, our qubit is along the direction of X-axis. Lets try to rotate it about z-axis with \\( \\frac{\\pi}{4} \\) angle. qc . u3( 0 , 0 ,np . pi / 4 , 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [0.70710678+0.j 0.5 +0.5j] Now, you got the idea! Lets rotate to complete \\( 2\\pi \\) rotation by adding 7 more u3 gates and return this qubit back to it's initial position by acting final H gate. for i in range ( 7 ): qc . u3( 0 , 0 ,np . pi / 4 , 0 ) qc . h( 0 ) style = { backgroundcolor : lavender } qc . draw(output = mpl , style = style) print (getStateVector(qc)) getBlochSphere(qc) [1.+0.j 0.+0.j] Yahoo....! Now, qubit is back to original position. This can be shown in animation below. What happens to the two complex cofficient of the qubit as it passes through the sequence of these gates? We can calculate individual phase angle and magnitude of the complex cofficient and visualize them as shown below.","title":"Bloch Sphere"}]}