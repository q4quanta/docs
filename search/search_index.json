{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quanta.Guru This online document helps the absolute beginners to persue the future direction in coding and Quantum Computing. The lesson starts with fundamental of qubits, quantum gates and quantum algorithms","title":"Home"},{"location":"#quantaguru","text":"This online document helps the absolute beginners to persue the future direction in coding and Quantum Computing. The lesson starts with fundamental of qubits, quantum gates and quantum algorithms","title":"Quanta.Guru"},{"location":"comingsoon/","text":"Coming Soon Under construction","title":"Comingsoon"},{"location":"comingsoon/#coming-soon","text":"Under construction","title":"Coming Soon"},{"location":"GettingStarted/anaconda/","text":"Installing Python To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python. Note- Linux: For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook Note - Cloud For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Guide to starting Python"},{"location":"GettingStarted/anaconda/#installing-python","text":"To install Anaconda Python follow the instruction at Anaconda Distribution Website . Based on the operating system select the proper version of the Anaconda package and install it in your PC. After you successfully install the proper version, you will get anaconda application in you PC which will look like the figure below: Best way to start with is the \"Jupyter notebook\". Lunch the jupyter notebook to start with Python.","title":"Installing Python"},{"location":"GettingStarted/anaconda/#note-linux","text":"For Linux user, it could be little bit tricky. SOme time it becomes hard to locate anaconda path to the environment so you need to point the python you want to use. Please, run the command below to point the python: bash export PATH=/home/ubuntu/anaconda3/bin:$PATH There is 'base' or 'anaconda3' environment by defult. You can find the list of available environmet by typing following command on the terminal bash conda env list To start the 'base' environment type bash source activate base To install new package for example 'jupyter notebook' type bash pip install jupyter notebook After sucessfully installing Jupyter notebook, tye following to start it bash Jupyter notebook","title":"Note- Linux:"},{"location":"GettingStarted/anaconda/#note-cloud","text":"For running Jupyter notebook in AWS cloud, it is important to open the \"8888\" to \"8889\" with TCP rule with IP \"0.0.0.0\" and allow to be opend from anywhere. Once port is open, type following to bash jupyter notebook --ip=0.0.0.0 --no-browser","title":"Note - Cloud"},{"location":"GettingStarted/env/","text":"Python Environment Basics To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = \"/Users/username/anaconda/bin: $PATH \" or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup Environments Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate Saving and loading environments A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export > environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, > environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml . Listing environments If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root . Removing environments If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ). Using environments One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican . Sharing environments When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda. More to learn To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"Setting up Python Environment"},{"location":"GettingStarted/env/#python-environment","text":"","title":"Python Environment"},{"location":"GettingStarted/env/#basics","text":"To avoid errors later, it's best to update all the packages in the default environment. Open the Anaconda Prompt application. In the prompt, run the following commands: conda upgrade conda conda upgrade --all If you are seeing the following \"conda command not found\" and are using ZShell, you have to do the following: export PATH = \"/Users/username/anaconda/bin: $PATH \" or update above command line to your .zsh_config file. Once you have Anaconda installed, managing packages is fairly straightforward. To install a package, type conda install package_name in your terminal. For example, to install numpy, type conda install numpy. You can install multiple packages at the same time. Something like conda install numpy scipy pandas will install all those packages simultaneously. It's also possible to specify which version of a package you want by adding the version number such as conda install numpy = 1 .10. Conda also automatically installs dependencies for you. For example scipy depends on numpy, it uses and requires numpy. If you install just scipy (conda install scipy), Conda will also install numpy if it isn't already installed. Most of the commands are pretty intuitive. To uninstall, use conda remove package_name To update a package conda update package_name If you want to update all packages in an environment, which is often useful, use conda update --all And finally, to list installed packages, it's conda list If you don't know the exact name of the package you're looking for, you can try searching with conda search search_term For example, I know I want to install Beautiful Soup, but I'm not sure of the exact package name. So, I try conda search beautifulsoup","title":"Basics"},{"location":"GettingStarted/env/#environments","text":"Conda can be used to create environments to isolate your projects. To create an environment, use conda create -n env_name list of packages in your terminal Here -n env_name sets the name of your environment (-n for name) and list of packages is the list of packages you want installed in the environment. For example, to create an environment named my_env and install numpy in it, type conda create -n my_env numpy When creating an environment, you can specify which version of Python to install in the environment. This is useful when you're working with code in both Python 2.x and Python 3.x. To create an environment with a specific Python version, do something like conda create -n py3 python = 3 or conda create -n py2 python = 2 I actually have both of these environments on my personal computer. I use them as general environments not tied to any specific project, but rather for general work with each Python version easily accessible. These commands will install the most recent version of Python 3 and 2, respectively. To install a specific version, use conda create -n py python = 3 .3 for Python 3.3. Once you have an environment created, use source activate my_env to enter it on OSX/Linux. On Windows, use activate my_env When you're in the environment, you'll see the environment name in the terminal prompt. Something like (my_env) ~ $. The environment has only a few packages installed by default, plus the ones you installed when creating it. You can check this out with conda list. Installing packages in the environment is the same as before: conda install package_name Only this time, the specific packages you install will only be available when you're in the environment. To leave the environment, type source deactivate ( on OSX/Linux ) On Windows, use deactivate","title":"Environments"},{"location":"GettingStarted/env/#saving-and-loading-environments","text":"A really useful feature is sharing environments so others can install all the packages used in your code, with the correct versions. You can save the packages to a YAML file with conda env export > environment.yaml The first part conda env export writes out all the packages in the environment, including the Python version. Above you can see the name of the environment and all the dependencies (along with versions) are listed. The second part of the export command, > environment.yaml writes the exported text to a YAML file environment.yaml . This file can now be shared and others will be able to create the same environment you used for the project. To create an environment from an environment file use conda env create -f environment.yaml This will create a new environment with the same name listed in environment.yaml .","title":"Saving and loading environments"},{"location":"GettingStarted/env/#listing-environments","text":"If you forget what your environments are named (happens to me sometimes), use conda env list to list out all the environments you've created. You should see a list of environments, there will be an asterisk next to the environment you're currently in. The default environment, the environment used when you aren't in one, is called root .","title":"Listing environments"},{"location":"GettingStarted/env/#removing-environments","text":"If there are environments you don't use anymore, conda env remove -n env_name will remove the specified environment (here, named env_name ).","title":"Removing environments"},{"location":"GettingStarted/env/#using-environments","text":"One thing that\u2019s helped me tremendously is having separate environments for Python 2 and Python 3. I used conda create -n py2 python = 2 and conda create -n py3 python = 3 to create two separate environments, py2 and py3 . Now I have a general use environment for each Python version. In each of those environments, I've installed most of the standard data science packages (numpy, scipy, pandas, etc.) I\u2019ve also found it useful to create environments for each project I\u2019m working on. It works great for non-data related projects too like web apps with Flask. For example, I have an environment for my personal blog using Pelican .","title":"Using environments"},{"location":"GettingStarted/env/#sharing-environments","text":"When sharing your code on GitHub, it's good practice to make an environment file and include it in the repository. This will make it easier for people to install all the dependencies for your code. I also usually include a pip requirements.txt file using pip freeze ( learn more here ) for people not using conda.","title":"Sharing environments"},{"location":"GettingStarted/env/#more-to-learn","text":"To learn more about conda and how it fits in the Python ecosystem, check out this article by Jake Vanderplas: Conda myths and misconceptions. And here's the conda documentation you can reference later.","title":"More to learn"},{"location":"GettingStarted/git/","text":"How to git Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m \"First commit\" Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to Git"},{"location":"GettingStarted/git/#how-to-git","text":"Reference : How to Git Create a new repository on GitHub. To avoid errors, do not initialize the new repository with README, license, or gitignore files. You can add these files after your project has been pushed to GitHub. Open Terminal. Change the current working directory to your local project. Initialize the local directory as a Git repository. git init Add the files in your new local repository. This stages them for the first commit. git add . Adds the files in the local repository and stages them for commit. To unstage a file, use 'git reset HEAD YOUR-FILE'. Commit the files that you've staged in your local repository. git commit -m \"First commit\" Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use 'git reset --soft HEAD~1' and commit and add the file again. Copy remote repository URL fieldAt the top of your GitHub repository's Quick Setup page, click to copy the remote repository URL. In Terminal, add the URL for the remote repository where your local repository will be pushed. git remote add origin remote repository URL Sets the new remote git remote -v Verifies the new remote URL Push the changes in your local repository to GitHub. git push origin master Pushes the changes in your local repository up to the remote repository you specified as the origin","title":"How to git"},{"location":"GettingStarted/jupyter/","text":"Installing Jupyter Notebook By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: https://nbconvert.readthedocs.io/en/latest/usage.html To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"GettingStarted/jupyter/#installing-jupyter-notebook","text":"By far the easiest way to install Jupyter is with Anaconda. Jupyter notebooks automatically come with the distribution. You'll be able to use notebooks from the default environment. To install Jupyter notebooks in a conda environment, use conda install jupyter notebook Jupyter notebooks are also available through pip with pip install jupyter notebook Markdown Cheatsheet : https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet Convert a notebook to an HTML file, in your terminal use jupyter nbconvert --to html notebook.ipynb Convert: https://nbconvert.readthedocs.io/en/latest/usage.html To create the slideshow from the notebook file, you'll need to use nbconvert: jupyter nbconvert notebook.ipynb --to slides This just converts the notebook to the necessary files for the slideshow, but you need to serve it with an HTTP server to actually see the presentation. To convert it and immediately see it, use jupyter nbconvert notebook.ipynb --to slides --post serve This will open up the slideshow in your browser so you can present it. panda presentation: presentation","title":"Installing Jupyter Notebook"},{"location":"GettingStarted/lib/","text":"Python Libraries Following are the best Python Libraries: TensorFlow Scikit-Learn Numpy Keras PyTorch LightGBM Eli5 SciPy Theano Pandas","title":"Guide to Python Libraries"},{"location":"GettingStarted/lib/#python-libraries","text":"Following are the best Python Libraries: TensorFlow Scikit-Learn Numpy Keras PyTorch LightGBM Eli5 SciPy Theano Pandas","title":"Python Libraries"},{"location":"References/ref/","text":"References Mkdocs Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"Reference"},{"location":"References/ref/#references","text":"","title":"References"},{"location":"References/ref/#mkdocs","text":"Deploy MkDocs MkDoc Black and Blue Codehilit Syntax highlight all Syntax highlight code","title":"Mkdocs"},{"location":"algorithms/grover/grover/","text":"Coming Soon Under construction","title":"Grover's Algorithm"},{"location":"algorithms/grover/grover/#coming-soon","text":"Under construction","title":"Coming Soon"},{"location":"algorithms/qft/qft/","text":"Quantum Fourier Transform Quantum Fourier Transform is quantum analogue of Fast Fourier Transform. In quantum computing, the quantum Fourier transform (for short: QFT) is a linear transformation on quantum bits, and is the quantum analogue of the inverse discrete Fourier transform. The quantum Fourier transform is a part of many quantum algorithms, notably Shor's algorithm for factoring and computing the discrete logarithm, the quantum phase estimation algorithm for estimating the eigenvalues of a unitary operator, and algorithms for the hidden subgroup problem. Wikipedia Import 'Quiskit' libraries % matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit,QuantumRegister,ClassicalRegister from qiskit import execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * Theory QFT is defined as $$ \\large{QFT:|x> = \\frac{1}{\\sqrt{N}}\\sum_{k=0}^{N-1} \\omega_{x}^{k}|k>}$$ where \\( \\omega_{x}^{k}\\) is \\( N^{th} (N = 2^{n})\\) root of unity: \\( e^{\\frac{2\\pi i}{2^{n}}}\\). $$ QFT_{N} = \\frac{1}{\\sqrt{N}} \\left( \\begin{array}{cccccc} 1 & 1 & 1 & 1 & \\cdots &1 \\\\ 1 & \\omega_{n} & \\omega_{n}^{2} & \\omega_{n}^{3} & \\cdots & \\omega_{n} ^{N-1} \\\\ 1 & \\omega_{n}^{2} & \\omega_{n}^{4} & \\omega_{n}^{6} & \\cdots & \\omega_{n} ^{2(N-1)} \\\\ 1 & \\omega_{n}^{3} &\\omega_{n}^{6} & \\omega_{n}^{9} & \\cdots & \\omega_{n} ^{3(N-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\dots & \\vdots \\\\ 1 & \\omega_{n}^{(N-1)} & \\omega_{n}^{2(N-1)} & \\omega_{n}^{3(N-1)} &\\cdots & \\omega_{n} ^{(N-1((N-1)} \\\\ \\end{array} \\right) $$ Single qubit QFT Theory For single qubit circuit \\( (n = 1, N = 2^{1} = 2)\\) and \\( \\omega_n = e^{\\frac{2\\pi i}{2^{n}}} = -1 \\). $$ QFT_{1} = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right)$$ How is state |0> transformed ? $$QFT_1|0> = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\left( \\begin{array}{c} 1 \\\\ 0 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{c} 1 \\\\ 1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} (|0> + |1>)$$ How is state |1> transformed ? $$QFT_1|1> = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\left( \\begin{array}{c} 0 \\\\ 1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{c} 1 \\\\ -1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} (|0> - |1>)$$ How is state \\( c_1|0> + c_2|1> \\) transformed? $$QFT_1(c_1|0> + c_2|1>) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\left( \\begin{array}{cc} c_1 \\\\ c_2 \\end{array} \\right)$$ $$ = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} c_1 + c_2 \\\\ c_2 - c1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} ((c_1 + c_2)|0> - (c_2 - c1)|1>)$$ How to realize the quantum circuit? It is Hadamard gate ! Quantum Circuit - single qubit QFT Quantum Circuit def qft_1 (): n = 1 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 0 ]) return qc,q,c Measurement qc,q,c = qft_1() qc . measure(q[ 0 ], c[ 0 ]) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style) Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' ) Unitary representation from qiskit.providers.aer import UnitarySimulator qc,q,c = qft_1() # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.70710678+0.j 0.70710678+0.j] [ 0.70710678+0.j -0.70710678+0.j]] Two qubit QFT Theory: For two qubit circuit, \\( (n =2, N = 2^{2} = 4) \\) where \\( \\omega_{n} = e^{\\frac{2\\pi i}{2^{n}}} = i\\). $$QFT_2 = \\frac{1}{{2}} \\left( \\begin{array}{cc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right)$$ How is state |00> transformed ? $$QFT_2|00> = \\frac{1}{{2}} \\left( \\begin{array}{cccc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right) \\left( \\begin{array}{c} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\end{array} \\right) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{c} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{array} \\right) = \\frac{1}{{2}} (|00> + |10> + |01> + |11>)$$ How is state \\( c_1|00> + c_2|10> + c_3 |01> + c_4 |11> \\) transformed? $$QFT_2|(c_1|00> + c_2|10> + c_3 |01> + c_4 |11>) = \\frac{1}{{2}} \\left( \\begin{array}{cccc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right) \\left( \\begin{array}{c} c_1 \\\\ c_2 \\\\ c_3 \\\\ c_4 \\\\ \\end{array} \\right) $$ $$= \\frac{1}{{2}} \\left( \\begin{array}{c} c_1 +c_2 +c_3 +c_4 \\\\ c_1 +ic_2 -c_3 -ic_4 \\\\ c_1 -c_2 +c_3 -c_4 \\\\ c_1 -ic_2 -c_3 +ic_4 \\end{array} \\right) = \\frac{1}{{2}} (d_1|00> + d_2|10> + d_3|01> + d_4|11>)$$ How to realize the quantum circuit? $$H \\otimes I = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\otimes \\left( \\begin{array}{cc} 1 & 0 \\\\ 0 & 1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0 \\\\ 0 & 1 & 0 & -1 \\end{array} \\right) $$ $$C_{u1} = \\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & i \\end{array} \\right)$$ $$I \\otimes H = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 0 \\\\ 0 & 1 \\end{array} \\right) \\otimes \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 1 & 0 & 0\\\\ 1 & -1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & -1 \\end{array} \\right) $$ $$ SWAP = \\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 1 \\end{array} \\right)$$ $$QFT_2 = (H \\otimes I) \\times C_{u1} \\times (I \\otimes H) \\times SWAP $$ $$ = \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0 \\\\ 0 & 1 & 0 & -1 \\end{array} \\right)\\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & i \\end{array} \\right)\\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 1 & 0 & 0\\\\ 1 & -1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & -1 \\end{array} \\right) \\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 1 \\end{array} \\right)$$ $$ = \\frac{1}{{2}} \\left( \\begin{array}{cccc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right)$$ Numpy check: HI = np . array([[ 1 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 0 , - 1 , 0 ],[ 0 , 1 , 0 , - 1 ]]) CU1 = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 0. + 1.j ]]) IH = np . array([[ 1 , 1 , 0 , 0 ],[ 1 , - 1 , 0 , 0 ],[ 0 , 0 , 1 , 1 ],[ 0 , 0 , 1 , - 1 ]]) SWAP = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 0 , 1 ]]) np . dot(HI,np . dot(CU1,np . dot(IH,SWAP))) array([[ 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j], [ 1.+0.j, 0.+1.j, -1.+0.j, 0.-1.j], [ 1.+0.j, -1.+0.j, 1.+0.j, -1.+0.j], [ 1.+0.j, 0.-1.j, -1.+0.j, 0.+1.j]]) Quantum Circuit - two qubit QFT import numpy as np Quantum circuit def qft_2 (): n = 2 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 1 ]) qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . h(q[ 0 ]) qc . swap(q[ 0 ], q[ 1 ]) return qc,q,c Measurement qc,q,c = qft_2() qc . measure(q, c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style) Manual approach: Initial state: |00> After Hadamard Gate on qubit 2 : \\(\\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|01> \\) After phase shift Gate : \\(\\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|01> \\) After Hadamard Gate on qubit 1 : \\(\\frac{1}{{2}}|00> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|01> - \\frac{1}{{2}}|11>\\) After SWAP: \\( \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> - \\frac{1}{{2}}|11>\\) Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' ) Unitary representation from qiskit.providers.aer import UnitarySimulator qc,q,c = qft_2() # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j ] [ 0.5+0.j 0. +0.5j -0.5+0.j 0. -0.5j] [ 0.5+0.j -0.5+0.j 0.5+0.j -0.5+0.j ] [ 0.5+0.j 0. -0.5j -0.5+0.j 0. +0.5j]] Quantum Circuit - three qubit QFT Quantum circuit def qft_3 (): n = 3 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 2 ]) qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc . h(q[ 1 ]) qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . h(q[ 0 ]) qc . swap(q[ 0 ], q[ 2 ]) return qc,q,c Measuremrnt qc,q,c = qft_3() qc . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style) Manual Approach: Initial state: |000> After Hadamard Gate on 3rd qubit : \\(\\frac{1}{\\sqrt{2}}(|000> + |001>) \\) After CU1 gate on qubit (2,3) : \\(\\frac{1}{\\sqrt{2}}(|000> + |001>) \\) After CU1 gate on qubit (1,3) : \\(\\frac{1}{\\sqrt{2}}(|000> + |001>) \\) After Hadamard Gate on qubit 2 : \\(\\frac{1}{{2}}(|000> + |010> + |001> -|011> )\\) After CU1 gate on qubit (0,1): \\(\\frac{1}{{2}}(|000> + |010> + |001> -|011> )\\) After Hadamard Gate on qubit 3 : \\(\\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |000> - |001> - |010> + |011)\\) Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' ) Unitary representation from qiskit.providers.aer import UnitarySimulator qc,q,c = qft_3() # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j ] [ 0.35355339+0.j 0.25 +0.25j 0. +0.35355339j -0.25 +0.25j -0.35355339+0.j -0.25 -0.25j 0. -0.35355339j 0.25 -0.25j ] [ 0.35355339+0.j 0. +0.35355339j -0.35355339+0.j 0. -0.35355339j 0.35355339+0.j 0. +0.35355339j -0.35355339+0.j 0. -0.35355339j] [ 0.35355339+0.j -0.25 +0.25j 0. -0.35355339j 0.25 +0.25j -0.35355339+0.j 0.25 -0.25j 0. +0.35355339j -0.25 -0.25j ] [ 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j ] [ 0.35355339+0.j -0.25 -0.25j 0. +0.35355339j 0.25 -0.25j -0.35355339+0.j 0.25 +0.25j 0. -0.35355339j -0.25 +0.25j ] [ 0.35355339+0.j 0. -0.35355339j -0.35355339+0.j 0. +0.35355339j 0.35355339+0.j 0. -0.35355339j -0.35355339+0.j 0. +0.35355339j] [ 0.35355339+0.j 0.25 -0.25j 0. -0.35355339j -0.25 -0.25j -0.35355339+0.j -0.25 +0.25j 0. +0.35355339j 0.25 +0.25j ]] Quantum Circuit - four qubit QFT Quantum circuit def qft_4 (): n = 4 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 3 ]) qc . cu1(np . pi / 2 , q[ 2 ], q[ 3 ]) qc . h(q[ 2 ]) qc . cu1(np . pi / 4 , q[ 1 ], q[ 3 ]) qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc . h(q[ 1 ]) qc . cu1(np . pi / 8 , q[ 0 ], q[ 3 ]) qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . h(q[ 0 ]) qc . swap(q[ 0 ], q[ 3 ]) qc . swap(q[ 1 ], q[ 2 ]) return qc,q,c Measurement qc,q,c = qft_4() qc . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style) Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' ) Unitary representation qc = qft_circuit( 4 ) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j ] [ 0.25 +0.j 0.23096988+0.09567086j 0.1767767 +0.1767767j 0.09567086+0.23096988j 0. +0.25j -0.09567086+0.23096988j -0.1767767 +0.1767767j -0.23096988+0.09567086j -0.25 +0.j -0.23096988-0.09567086j -0.1767767 -0.1767767j -0.09567086-0.23096988j 0. -0.25j 0.09567086-0.23096988j 0.1767767 -0.1767767j 0.23096988-0.09567086j] [ 0.25 +0.j 0.1767767 +0.1767767j 0. +0.25j -0.1767767 +0.1767767j -0.25 +0.j -0.1767767 -0.1767767j 0. -0.25j 0.1767767 -0.1767767j 0.25 +0.j 0.1767767 +0.1767767j 0. +0.25j -0.1767767 +0.1767767j -0.25 +0.j -0.1767767 -0.1767767j 0. -0.25j 0.1767767 -0.1767767j ] [ 0.25 +0.j 0.09567086+0.23096988j -0.1767767 +0.1767767j -0.23096988-0.09567086j 0. -0.25j 0.23096988-0.09567086j 0.1767767 +0.1767767j -0.09567086+0.23096988j -0.25 +0.j -0.09567086-0.23096988j 0.1767767 -0.1767767j 0.23096988+0.09567086j 0. +0.25j -0.23096988+0.09567086j -0.1767767 -0.1767767j 0.09567086-0.23096988j] [ 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j ] [ 0.25 +0.j -0.09567086+0.23096988j -0.1767767 -0.1767767j 0.23096988-0.09567086j 0. +0.25j -0.23096988-0.09567086j 0.1767767 -0.1767767j 0.09567086+0.23096988j -0.25 +0.j 0.09567086-0.23096988j 0.1767767 +0.1767767j -0.23096988+0.09567086j 0. -0.25j 0.23096988+0.09567086j -0.1767767 +0.1767767j -0.09567086-0.23096988j] [ 0.25 +0.j -0.1767767 +0.1767767j 0. -0.25j 0.1767767 +0.1767767j -0.25 +0.j 0.1767767 -0.1767767j 0. +0.25j -0.1767767 -0.1767767j 0.25 +0.j -0.1767767 +0.1767767j 0. -0.25j 0.1767767 +0.1767767j -0.25 +0.j 0.1767767 -0.1767767j 0. +0.25j -0.1767767 -0.1767767j ] [ 0.25 +0.j -0.23096988+0.09567086j 0.1767767 -0.1767767j -0.09567086+0.23096988j 0. -0.25j 0.09567086+0.23096988j -0.1767767 -0.1767767j 0.23096988+0.09567086j -0.25 +0.j 0.23096988-0.09567086j -0.1767767 +0.1767767j 0.09567086-0.23096988j 0. +0.25j -0.09567086-0.23096988j 0.1767767 +0.1767767j -0.23096988-0.09567086j] [ 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j ] [ 0.25 +0.j -0.23096988-0.09567086j 0.1767767 +0.1767767j -0.09567086-0.23096988j 0. +0.25j 0.09567086-0.23096988j -0.1767767 +0.1767767j 0.23096988-0.09567086j -0.25 +0.j 0.23096988+0.09567086j -0.1767767 -0.1767767j 0.09567086+0.23096988j 0. -0.25j -0.09567086+0.23096988j 0.1767767 -0.1767767j -0.23096988+0.09567086j] [ 0.25 +0.j -0.1767767 -0.1767767j 0. +0.25j 0.1767767 -0.1767767j -0.25 +0.j 0.1767767 +0.1767767j 0. -0.25j -0.1767767 +0.1767767j 0.25 +0.j -0.1767767 -0.1767767j 0. +0.25j 0.1767767 -0.1767767j -0.25 +0.j 0.1767767 +0.1767767j 0. -0.25j -0.1767767 +0.1767767j ] [ 0.25 +0.j -0.09567086-0.23096988j -0.1767767 +0.1767767j 0.23096988+0.09567086j 0. -0.25j -0.23096988+0.09567086j 0.1767767 +0.1767767j 0.09567086-0.23096988j -0.25 +0.j 0.09567086+0.23096988j 0.1767767 -0.1767767j -0.23096988-0.09567086j 0. +0.25j 0.23096988-0.09567086j -0.1767767 -0.1767767j -0.09567086+0.23096988j] [ 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j ] [ 0.25 +0.j 0.09567086-0.23096988j -0.1767767 -0.1767767j -0.23096988+0.09567086j 0. +0.25j 0.23096988+0.09567086j 0.1767767 -0.1767767j -0.09567086-0.23096988j -0.25 +0.j -0.09567086+0.23096988j 0.1767767 +0.1767767j 0.23096988-0.09567086j 0. -0.25j -0.23096988-0.09567086j -0.1767767 +0.1767767j 0.09567086+0.23096988j] [ 0.25 +0.j 0.1767767 -0.1767767j 0. -0.25j -0.1767767 -0.1767767j -0.25 +0.j -0.1767767 +0.1767767j 0. +0.25j 0.1767767 +0.1767767j 0.25 +0.j 0.1767767 -0.1767767j 0. -0.25j -0.1767767 -0.1767767j -0.25 +0.j -0.1767767 +0.1767767j 0. +0.25j 0.1767767 +0.1767767j ] [ 0.25 +0.j 0.23096988-0.09567086j 0.1767767 -0.1767767j 0.09567086-0.23096988j 0. -0.25j -0.09567086-0.23096988j -0.1767767 -0.1767767j -0.23096988-0.09567086j -0.25 +0.j -0.23096988+0.09567086j -0.1767767 +0.1767767j -0.09567086+0.23096988j 0. +0.25j 0.09567086+0.23096988j 0.1767767 +0.1767767j 0.23096988+0.09567086j]] References https://www.youtube.com/watch?v=bntew-yoMzk","title":"Quantum Fourier Transform"},{"location":"algorithms/qft/qft/#quantum-fourier-transform","text":"Quantum Fourier Transform is quantum analogue of Fast Fourier Transform. In quantum computing, the quantum Fourier transform (for short: QFT) is a linear transformation on quantum bits, and is the quantum analogue of the inverse discrete Fourier transform. The quantum Fourier transform is a part of many quantum algorithms, notably Shor's algorithm for factoring and computing the discrete logarithm, the quantum phase estimation algorithm for estimating the eigenvalues of a unitary operator, and algorithms for the hidden subgroup problem. Wikipedia Import 'Quiskit' libraries % matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit,QuantumRegister,ClassicalRegister from qiskit import execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import *","title":"Quantum Fourier Transform"},{"location":"algorithms/qft/qft/#theory","text":"QFT is defined as $$ \\large{QFT:|x> = \\frac{1}{\\sqrt{N}}\\sum_{k=0}^{N-1} \\omega_{x}^{k}|k>}$$ where \\( \\omega_{x}^{k}\\) is \\( N^{th} (N = 2^{n})\\) root of unity: \\( e^{\\frac{2\\pi i}{2^{n}}}\\). $$ QFT_{N} = \\frac{1}{\\sqrt{N}} \\left( \\begin{array}{cccccc} 1 & 1 & 1 & 1 & \\cdots &1 \\\\ 1 & \\omega_{n} & \\omega_{n}^{2} & \\omega_{n}^{3} & \\cdots & \\omega_{n} ^{N-1} \\\\ 1 & \\omega_{n}^{2} & \\omega_{n}^{4} & \\omega_{n}^{6} & \\cdots & \\omega_{n} ^{2(N-1)} \\\\ 1 & \\omega_{n}^{3} &\\omega_{n}^{6} & \\omega_{n}^{9} & \\cdots & \\omega_{n} ^{3(N-1)} \\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\dots & \\vdots \\\\ 1 & \\omega_{n}^{(N-1)} & \\omega_{n}^{2(N-1)} & \\omega_{n}^{3(N-1)} &\\cdots & \\omega_{n} ^{(N-1((N-1)} \\\\ \\end{array} \\right) $$","title":"Theory"},{"location":"algorithms/qft/qft/#single-qubit-qft","text":"","title":"Single qubit QFT"},{"location":"algorithms/qft/qft/#theory_1","text":"For single qubit circuit \\( (n = 1, N = 2^{1} = 2)\\) and \\( \\omega_n = e^{\\frac{2\\pi i}{2^{n}}} = -1 \\). $$ QFT_{1} = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right)$$ How is state |0> transformed ? $$QFT_1|0> = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\left( \\begin{array}{c} 1 \\\\ 0 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{c} 1 \\\\ 1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} (|0> + |1>)$$ How is state |1> transformed ? $$QFT_1|1> = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\left( \\begin{array}{c} 0 \\\\ 1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{c} 1 \\\\ -1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} (|0> - |1>)$$ How is state \\( c_1|0> + c_2|1> \\) transformed? $$QFT_1(c_1|0> + c_2|1>) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\left( \\begin{array}{cc} c_1 \\\\ c_2 \\end{array} \\right)$$ $$ = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} c_1 + c_2 \\\\ c_2 - c1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}} ((c_1 + c_2)|0> - (c_2 - c1)|1>)$$ How to realize the quantum circuit? It is Hadamard gate !","title":"Theory"},{"location":"algorithms/qft/qft/#quantum-circuit-single-qubit-qft","text":"","title":"Quantum Circuit - single qubit QFT"},{"location":"algorithms/qft/qft/#quantum-circuit","text":"def qft_1 (): n = 1 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 0 ]) return qc,q,c","title":"Quantum Circuit"},{"location":"algorithms/qft/qft/#measurement","text":"qc,q,c = qft_1() qc . measure(q[ 0 ], c[ 0 ]) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style)","title":"Measurement"},{"location":"algorithms/qft/qft/#simulation","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' )","title":"Simulation"},{"location":"algorithms/qft/qft/#unitary-representation","text":"from qiskit.providers.aer import UnitarySimulator qc,q,c = qft_1() # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.70710678+0.j 0.70710678+0.j] [ 0.70710678+0.j -0.70710678+0.j]]","title":"Unitary representation"},{"location":"algorithms/qft/qft/#two-qubit-qft","text":"","title":"Two qubit QFT"},{"location":"algorithms/qft/qft/#theory_2","text":"For two qubit circuit, \\( (n =2, N = 2^{2} = 4) \\) where \\( \\omega_{n} = e^{\\frac{2\\pi i}{2^{n}}} = i\\). $$QFT_2 = \\frac{1}{{2}} \\left( \\begin{array}{cc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right)$$ How is state |00> transformed ? $$QFT_2|00> = \\frac{1}{{2}} \\left( \\begin{array}{cccc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right) \\left( \\begin{array}{c} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ \\end{array} \\right) = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{c} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{array} \\right) = \\frac{1}{{2}} (|00> + |10> + |01> + |11>)$$ How is state \\( c_1|00> + c_2|10> + c_3 |01> + c_4 |11> \\) transformed? $$QFT_2|(c_1|00> + c_2|10> + c_3 |01> + c_4 |11>) = \\frac{1}{{2}} \\left( \\begin{array}{cccc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right) \\left( \\begin{array}{c} c_1 \\\\ c_2 \\\\ c_3 \\\\ c_4 \\\\ \\end{array} \\right) $$ $$= \\frac{1}{{2}} \\left( \\begin{array}{c} c_1 +c_2 +c_3 +c_4 \\\\ c_1 +ic_2 -c_3 -ic_4 \\\\ c_1 -c_2 +c_3 -c_4 \\\\ c_1 -ic_2 -c_3 +ic_4 \\end{array} \\right) = \\frac{1}{{2}} (d_1|00> + d_2|10> + d_3|01> + d_4|11>)$$ How to realize the quantum circuit? $$H \\otimes I = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) \\otimes \\left( \\begin{array}{cc} 1 & 0 \\\\ 0 & 1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0 \\\\ 0 & 1 & 0 & -1 \\end{array} \\right) $$ $$C_{u1} = \\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & i \\end{array} \\right)$$ $$I \\otimes H = \\frac{1}{\\sqrt{2}} \\left( \\begin{array}{cc} 1 & 0 \\\\ 0 & 1 \\end{array} \\right) \\otimes \\left( \\begin{array}{cc} 1 & 1 \\\\ 1 & -1 \\end{array} \\right) = \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 1 & 0 & 0\\\\ 1 & -1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & -1 \\end{array} \\right) $$ $$ SWAP = \\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 1 \\end{array} \\right)$$ $$QFT_2 = (H \\otimes I) \\times C_{u1} \\times (I \\otimes H) \\times SWAP $$ $$ = \\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0 \\\\ 0 & 1 & 0 & -1 \\end{array} \\right)\\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & i \\end{array} \\right)\\frac{1}{\\sqrt{2}}\\left( \\begin{array}{cccc} 1 & 1 & 0 & 0\\\\ 1 & -1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & -1 \\end{array} \\right) \\left( \\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 1 \\end{array} \\right)$$ $$ = \\frac{1}{{2}} \\left( \\begin{array}{cccc} 1 & 1 & 1 & 1\\\\ 1 & i & -1 & -i\\\\ 1 & -1 & 1 & -1\\\\ 1 & -i & -1 & i \\end{array} \\right)$$ Numpy check: HI = np . array([[ 1 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 0 , - 1 , 0 ],[ 0 , 1 , 0 , - 1 ]]) CU1 = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 0 , 0 , 0. + 1.j ]]) IH = np . array([[ 1 , 1 , 0 , 0 ],[ 1 , - 1 , 0 , 0 ],[ 0 , 0 , 1 , 1 ],[ 0 , 0 , 1 , - 1 ]]) SWAP = np . array([[ 1 , 0 , 0 , 0 ],[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 0 ],[ 0 , 0 , 0 , 1 ]]) np . dot(HI,np . dot(CU1,np . dot(IH,SWAP))) array([[ 1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j], [ 1.+0.j, 0.+1.j, -1.+0.j, 0.-1.j], [ 1.+0.j, -1.+0.j, 1.+0.j, -1.+0.j], [ 1.+0.j, 0.-1.j, -1.+0.j, 0.+1.j]])","title":"Theory:"},{"location":"algorithms/qft/qft/#quantum-circuit-two-qubit-qft","text":"import numpy as np","title":"Quantum Circuit - two qubit QFT"},{"location":"algorithms/qft/qft/#quantum-circuit_1","text":"def qft_2 (): n = 2 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 1 ]) qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . h(q[ 0 ]) qc . swap(q[ 0 ], q[ 1 ]) return qc,q,c","title":"Quantum circuit"},{"location":"algorithms/qft/qft/#measurement_1","text":"qc,q,c = qft_2() qc . measure(q, c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style)","title":"Measurement"},{"location":"algorithms/qft/qft/#manual-approach","text":"Initial state: |00> After Hadamard Gate on qubit 2 : \\(\\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|01> \\) After phase shift Gate : \\(\\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|01> \\) After Hadamard Gate on qubit 1 : \\(\\frac{1}{{2}}|00> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|01> - \\frac{1}{{2}}|11>\\) After SWAP: \\( \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> - \\frac{1}{{2}}|11>\\)","title":"Manual approach:"},{"location":"algorithms/qft/qft/#simulation_1","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' )","title":"Simulation"},{"location":"algorithms/qft/qft/#unitary-representation_1","text":"from qiskit.providers.aer import UnitarySimulator qc,q,c = qft_2() # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j ] [ 0.5+0.j 0. +0.5j -0.5+0.j 0. -0.5j] [ 0.5+0.j -0.5+0.j 0.5+0.j -0.5+0.j ] [ 0.5+0.j 0. -0.5j -0.5+0.j 0. +0.5j]]","title":"Unitary representation"},{"location":"algorithms/qft/qft/#quantum-circuit-three-qubit-qft","text":"","title":"Quantum Circuit - three qubit QFT"},{"location":"algorithms/qft/qft/#quantum-circuit_2","text":"def qft_3 (): n = 3 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 2 ]) qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc . h(q[ 1 ]) qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . h(q[ 0 ]) qc . swap(q[ 0 ], q[ 2 ]) return qc,q,c","title":"Quantum circuit"},{"location":"algorithms/qft/qft/#measuremrnt","text":"qc,q,c = qft_3() qc . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style)","title":"Measuremrnt"},{"location":"algorithms/qft/qft/#manual-approach_1","text":"Initial state: |000> After Hadamard Gate on 3rd qubit : \\(\\frac{1}{\\sqrt{2}}(|000> + |001>) \\) After CU1 gate on qubit (2,3) : \\(\\frac{1}{\\sqrt{2}}(|000> + |001>) \\) After CU1 gate on qubit (1,3) : \\(\\frac{1}{\\sqrt{2}}(|000> + |001>) \\) After Hadamard Gate on qubit 2 : \\(\\frac{1}{{2}}(|000> + |010> + |001> -|011> )\\) After CU1 gate on qubit (0,1): \\(\\frac{1}{{2}}(|000> + |010> + |001> -|011> )\\) After Hadamard Gate on qubit 3 : \\(\\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |000> - |001> - |010> + |011)\\)","title":"Manual Approach:"},{"location":"algorithms/qft/qft/#simulation_2","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' )","title":"Simulation"},{"location":"algorithms/qft/qft/#unitary-representation_2","text":"from qiskit.providers.aer import UnitarySimulator qc,q,c = qft_3() # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j ] [ 0.35355339+0.j 0.25 +0.25j 0. +0.35355339j -0.25 +0.25j -0.35355339+0.j -0.25 -0.25j 0. -0.35355339j 0.25 -0.25j ] [ 0.35355339+0.j 0. +0.35355339j -0.35355339+0.j 0. -0.35355339j 0.35355339+0.j 0. +0.35355339j -0.35355339+0.j 0. -0.35355339j] [ 0.35355339+0.j -0.25 +0.25j 0. -0.35355339j 0.25 +0.25j -0.35355339+0.j 0.25 -0.25j 0. +0.35355339j -0.25 -0.25j ] [ 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j ] [ 0.35355339+0.j -0.25 -0.25j 0. +0.35355339j 0.25 -0.25j -0.35355339+0.j 0.25 +0.25j 0. -0.35355339j -0.25 +0.25j ] [ 0.35355339+0.j 0. -0.35355339j -0.35355339+0.j 0. +0.35355339j 0.35355339+0.j 0. -0.35355339j -0.35355339+0.j 0. +0.35355339j] [ 0.35355339+0.j 0.25 -0.25j 0. -0.35355339j -0.25 -0.25j -0.35355339+0.j -0.25 +0.25j 0. +0.35355339j 0.25 +0.25j ]]","title":"Unitary representation"},{"location":"algorithms/qft/qft/#quantum-circuit-four-qubit-qft","text":"","title":"Quantum Circuit - four qubit QFT"},{"location":"algorithms/qft/qft/#quantum-circuit_3","text":"def qft_4 (): n = 4 qc = QuantumCircuit() q = QuantumRegister(n, 'q' ) c = ClassicalRegister(n, 'c' ) qc . add_register(q) qc . add_register(c) qc . h(q[ 3 ]) qc . cu1(np . pi / 2 , q[ 2 ], q[ 3 ]) qc . h(q[ 2 ]) qc . cu1(np . pi / 4 , q[ 1 ], q[ 3 ]) qc . cu1(np . pi / 2 , q[ 1 ], q[ 2 ]) qc . h(q[ 1 ]) qc . cu1(np . pi / 8 , q[ 0 ], q[ 3 ]) qc . cu1(np . pi / 4 , q[ 0 ], q[ 2 ]) qc . cu1(np . pi / 2 , q[ 0 ], q[ 1 ]) qc . h(q[ 0 ]) qc . swap(q[ 0 ], q[ 3 ]) qc . swap(q[ 1 ], q[ 2 ]) return qc,q,c","title":"Quantum circuit"},{"location":"algorithms/qft/qft/#measurement_2","text":"qc,q,c = qft_4() qc . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } qc . draw(output = 'mpl' , style = style)","title":"Measurement"},{"location":"algorithms/qft/qft/#simulation_3","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(qc, simulator) . result() counts = result . get_counts(qc) plot_histogram(counts, title = 'QFT counts' )","title":"Simulation"},{"location":"algorithms/qft/qft/#unitary-representation_3","text":"qc = qft_circuit( 4 ) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(qc, simulator) . result() unitary = result . get_unitary(qc) print ( unitary) [[ 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j 0.25 +0.j ] [ 0.25 +0.j 0.23096988+0.09567086j 0.1767767 +0.1767767j 0.09567086+0.23096988j 0. +0.25j -0.09567086+0.23096988j -0.1767767 +0.1767767j -0.23096988+0.09567086j -0.25 +0.j -0.23096988-0.09567086j -0.1767767 -0.1767767j -0.09567086-0.23096988j 0. -0.25j 0.09567086-0.23096988j 0.1767767 -0.1767767j 0.23096988-0.09567086j] [ 0.25 +0.j 0.1767767 +0.1767767j 0. +0.25j -0.1767767 +0.1767767j -0.25 +0.j -0.1767767 -0.1767767j 0. -0.25j 0.1767767 -0.1767767j 0.25 +0.j 0.1767767 +0.1767767j 0. +0.25j -0.1767767 +0.1767767j -0.25 +0.j -0.1767767 -0.1767767j 0. -0.25j 0.1767767 -0.1767767j ] [ 0.25 +0.j 0.09567086+0.23096988j -0.1767767 +0.1767767j -0.23096988-0.09567086j 0. -0.25j 0.23096988-0.09567086j 0.1767767 +0.1767767j -0.09567086+0.23096988j -0.25 +0.j -0.09567086-0.23096988j 0.1767767 -0.1767767j 0.23096988+0.09567086j 0. +0.25j -0.23096988+0.09567086j -0.1767767 -0.1767767j 0.09567086-0.23096988j] [ 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j 0.25 +0.j 0. +0.25j -0.25 +0.j 0. -0.25j ] [ 0.25 +0.j -0.09567086+0.23096988j -0.1767767 -0.1767767j 0.23096988-0.09567086j 0. +0.25j -0.23096988-0.09567086j 0.1767767 -0.1767767j 0.09567086+0.23096988j -0.25 +0.j 0.09567086-0.23096988j 0.1767767 +0.1767767j -0.23096988+0.09567086j 0. -0.25j 0.23096988+0.09567086j -0.1767767 +0.1767767j -0.09567086-0.23096988j] [ 0.25 +0.j -0.1767767 +0.1767767j 0. -0.25j 0.1767767 +0.1767767j -0.25 +0.j 0.1767767 -0.1767767j 0. +0.25j -0.1767767 -0.1767767j 0.25 +0.j -0.1767767 +0.1767767j 0. -0.25j 0.1767767 +0.1767767j -0.25 +0.j 0.1767767 -0.1767767j 0. +0.25j -0.1767767 -0.1767767j ] [ 0.25 +0.j -0.23096988+0.09567086j 0.1767767 -0.1767767j -0.09567086+0.23096988j 0. -0.25j 0.09567086+0.23096988j -0.1767767 -0.1767767j 0.23096988+0.09567086j -0.25 +0.j 0.23096988-0.09567086j -0.1767767 +0.1767767j 0.09567086-0.23096988j 0. +0.25j -0.09567086-0.23096988j 0.1767767 +0.1767767j -0.23096988-0.09567086j] [ 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j 0.25 +0.j -0.25 +0.j ] [ 0.25 +0.j -0.23096988-0.09567086j 0.1767767 +0.1767767j -0.09567086-0.23096988j 0. +0.25j 0.09567086-0.23096988j -0.1767767 +0.1767767j 0.23096988-0.09567086j -0.25 +0.j 0.23096988+0.09567086j -0.1767767 -0.1767767j 0.09567086+0.23096988j 0. -0.25j -0.09567086+0.23096988j 0.1767767 -0.1767767j -0.23096988+0.09567086j] [ 0.25 +0.j -0.1767767 -0.1767767j 0. +0.25j 0.1767767 -0.1767767j -0.25 +0.j 0.1767767 +0.1767767j 0. -0.25j -0.1767767 +0.1767767j 0.25 +0.j -0.1767767 -0.1767767j 0. +0.25j 0.1767767 -0.1767767j -0.25 +0.j 0.1767767 +0.1767767j 0. -0.25j -0.1767767 +0.1767767j ] [ 0.25 +0.j -0.09567086-0.23096988j -0.1767767 +0.1767767j 0.23096988+0.09567086j 0. -0.25j -0.23096988+0.09567086j 0.1767767 +0.1767767j 0.09567086-0.23096988j -0.25 +0.j 0.09567086+0.23096988j 0.1767767 -0.1767767j -0.23096988-0.09567086j 0. +0.25j 0.23096988-0.09567086j -0.1767767 -0.1767767j -0.09567086+0.23096988j] [ 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j 0.25 +0.j 0. -0.25j -0.25 +0.j 0. +0.25j ] [ 0.25 +0.j 0.09567086-0.23096988j -0.1767767 -0.1767767j -0.23096988+0.09567086j 0. +0.25j 0.23096988+0.09567086j 0.1767767 -0.1767767j -0.09567086-0.23096988j -0.25 +0.j -0.09567086+0.23096988j 0.1767767 +0.1767767j 0.23096988-0.09567086j 0. -0.25j -0.23096988-0.09567086j -0.1767767 +0.1767767j 0.09567086+0.23096988j] [ 0.25 +0.j 0.1767767 -0.1767767j 0. -0.25j -0.1767767 -0.1767767j -0.25 +0.j -0.1767767 +0.1767767j 0. +0.25j 0.1767767 +0.1767767j 0.25 +0.j 0.1767767 -0.1767767j 0. -0.25j -0.1767767 -0.1767767j -0.25 +0.j -0.1767767 +0.1767767j 0. +0.25j 0.1767767 +0.1767767j ] [ 0.25 +0.j 0.23096988-0.09567086j 0.1767767 -0.1767767j 0.09567086-0.23096988j 0. -0.25j -0.09567086-0.23096988j -0.1767767 -0.1767767j -0.23096988-0.09567086j -0.25 +0.j -0.23096988+0.09567086j -0.1767767 +0.1767767j -0.09567086+0.23096988j 0. +0.25j 0.09567086+0.23096988j 0.1767767 +0.1767767j 0.23096988+0.09567086j]]","title":"Unitary representation"},{"location":"algorithms/qft/qft/#references","text":"https://www.youtube.com/watch?v=bntew-yoMzk","title":"References"},{"location":"algorithms/shor/shor/","text":"Coming Soon Under construction","title":"Shor's Algorithm"},{"location":"algorithms/shor/shor/#coming-soon","text":"Under construction","title":"Coming Soon"},{"location":"circuits/bell/bell/","text":"Bell State The Bell states, a concept in quantum information science, are specific quantum states of two qubits that represent the simplest (and maximal) examples of quantum entanglement. The Bell states are a form of entangled and normalized basis vectors. This normalization implies that the overall probability of the particle being in one of the mentioned states is 1.[Wikipedia] Import 'Qiskit' libraries % matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit,QuantumRegister,ClassicalRegister, execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * Bell state Circuit Design Bell state circuit. num_qubits = 2 ; num_bits = 2 ; bell = QuantumCircuit( 2 , 2 ) bell . h( 0 ) bell . cx( 0 , 1 ) bell . measure([ 0 , 1 ], [ 0 , 1 ]) bell . draw(output = 'mpl' ) Manual approach initial state = |00> After application of Hadamard Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|10> \\) After application of CNOT Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|11> \\) Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(bell, simulator) . result() counts = result . get_counts(bell) plot_histogram(counts, title = 'Bell-State counts' ) Extended Circuit -1 Extend the bell state circuit by adding one more Hadamard gate on second qubit and CNOT gate. num_qubits = 2 ; num_bits = 2 ; bell = QuantumCircuit( 2 , 2 ) bell . h( 0 ) bell . cx( 0 , 1 ) bell . h( 1 ) bell . cx( 0 , 1 ) bell . measure([ 0 , 1 ], [ 0 , 1 ]) bell . draw(output = 'mpl' ) Manual approach: Initial state = |00> After application of Hadamard Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|10> \\) After application of CNOT Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|11> \\) After application of Hadamard Gate: \\( \\frac{1}{2}|00> + \\frac{1}{2}|01> + \\frac{1}{2}|10> - \\frac{1}{2}|11> \\) After application of CNOT Gate: \\( \\frac{1}{2}|00> + \\frac{1}{2}|01> + \\frac{1}{2}|11> - \\frac{1}{2}|10> \\) Simulation simulator = Aer.get_backend('qasm_simulator') result = execute(bell, simulator).result() counts = result.get_counts(bell) plot_histogram(counts, title='Bell-State counts') Extended Bell Circuit - 2 Extend the bell state circuit by adding two more Hadamard gates and two CNOT gates with three qubits. n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . cx(q[ 0 ], q[ 1 ]) circ . h(q[ 1 ]) circ . cx(q[ 1 ], q[ 2 ]) circ . h(q[ 2 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style) Manual approach Initial state: |000> After Hadamard Gate : \\( \\frac{1}{\\sqrt{2}}|000> + \\frac{1}{\\sqrt{2}}|100> \\) After CNOT Gate : \\( \\frac{1}{\\sqrt{2}}|000> + \\frac{1}{\\sqrt{2}}|110> \\) After Hadamard Gate :\\( \\frac{1}{{2}}|000> + \\frac{1}{{2}}|010> + \\frac{1}{{2}}|100> - \\frac{1}{{2}}|110>\\) After CNOT Gate :\\( \\frac{1}{{2}}|000> + \\frac{1}{{2}}|011> + \\frac{1}{{2}}|100> - \\frac{1}{{2}}|111>\\) After Hadamard Gate :\\( \\frac{1}{2\\sqrt{2}}( |000> + |001> + |010> - |011> + |100> + |101> - |110> + |111>) \\) Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' ) Reference https://www.quantum-inspire.com/kbase/hadamard/","title":"Bell state"},{"location":"circuits/bell/bell/#bell-state","text":"The Bell states, a concept in quantum information science, are specific quantum states of two qubits that represent the simplest (and maximal) examples of quantum entanglement. The Bell states are a form of entangled and normalized basis vectors. This normalization implies that the overall probability of the particle being in one of the mentioned states is 1.[Wikipedia] Import 'Qiskit' libraries % matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit,QuantumRegister,ClassicalRegister, execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import *","title":"Bell State"},{"location":"circuits/bell/bell/#bell-state-circuit","text":"Design Bell state circuit. num_qubits = 2 ; num_bits = 2 ; bell = QuantumCircuit( 2 , 2 ) bell . h( 0 ) bell . cx( 0 , 1 ) bell . measure([ 0 , 1 ], [ 0 , 1 ]) bell . draw(output = 'mpl' )","title":"Bell state Circuit"},{"location":"circuits/bell/bell/#manual-approach","text":"initial state = |00> After application of Hadamard Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|10> \\) After application of CNOT Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|11> \\)","title":"Manual approach"},{"location":"circuits/bell/bell/#simulation","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(bell, simulator) . result() counts = result . get_counts(bell) plot_histogram(counts, title = 'Bell-State counts' )","title":"Simulation"},{"location":"circuits/bell/bell/#extended-circuit-1","text":"Extend the bell state circuit by adding one more Hadamard gate on second qubit and CNOT gate. num_qubits = 2 ; num_bits = 2 ; bell = QuantumCircuit( 2 , 2 ) bell . h( 0 ) bell . cx( 0 , 1 ) bell . h( 1 ) bell . cx( 0 , 1 ) bell . measure([ 0 , 1 ], [ 0 , 1 ]) bell . draw(output = 'mpl' )","title":"Extended Circuit -1"},{"location":"circuits/bell/bell/#manual-approach_1","text":"Initial state = |00> After application of Hadamard Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|10> \\) After application of CNOT Gate: \\( \\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|11> \\) After application of Hadamard Gate: \\( \\frac{1}{2}|00> + \\frac{1}{2}|01> + \\frac{1}{2}|10> - \\frac{1}{2}|11> \\) After application of CNOT Gate: \\( \\frac{1}{2}|00> + \\frac{1}{2}|01> + \\frac{1}{2}|11> - \\frac{1}{2}|10> \\)","title":"Manual approach:"},{"location":"circuits/bell/bell/#simulation_1","text":"simulator = Aer.get_backend('qasm_simulator') result = execute(bell, simulator).result() counts = result.get_counts(bell) plot_histogram(counts, title='Bell-State counts')","title":"Simulation"},{"location":"circuits/bell/bell/#extended-bell-circuit-2","text":"Extend the bell state circuit by adding two more Hadamard gates and two CNOT gates with three qubits. n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . cx(q[ 0 ], q[ 1 ]) circ . h(q[ 1 ]) circ . cx(q[ 1 ], q[ 2 ]) circ . h(q[ 2 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style)","title":"Extended Bell Circuit - 2"},{"location":"circuits/bell/bell/#manual-approach_2","text":"Initial state: |000> After Hadamard Gate : \\( \\frac{1}{\\sqrt{2}}|000> + \\frac{1}{\\sqrt{2}}|100> \\) After CNOT Gate : \\( \\frac{1}{\\sqrt{2}}|000> + \\frac{1}{\\sqrt{2}}|110> \\) After Hadamard Gate :\\( \\frac{1}{{2}}|000> + \\frac{1}{{2}}|010> + \\frac{1}{{2}}|100> - \\frac{1}{{2}}|110>\\) After CNOT Gate :\\( \\frac{1}{{2}}|000> + \\frac{1}{{2}}|011> + \\frac{1}{{2}}|100> - \\frac{1}{{2}}|111>\\) After Hadamard Gate :\\( \\frac{1}{2\\sqrt{2}}( |000> + |001> + |010> - |011> + |100> + |101> - |110> + |111>) \\)","title":"Manual approach"},{"location":"circuits/bell/bell/#simulation_2","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' )","title":"Simulation"},{"location":"circuits/bell/bell/#reference","text":"https://www.quantum-inspire.com/kbase/hadamard/","title":"Reference"},{"location":"circuits/hadamard/hadamard/","text":"Hadamard Gate and Circuits Hadamard gate is single qubit operator. This transforms |0> state to a superposed state \\(\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>\\) and stae|1> to a superposed state \\(\\frac{1}{\\sqrt{2}}|0> - \\frac{1}{\\sqrt{2}}|1>\\). This gate is very important gate to construct Bell state, Quantum Fourier Transform (QFT) and many more. Import python library to perform computation in 'Qiskit' environment. % matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit, QuantumRegister,ClassicalRegister from qiskit import execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.aer import UnitarySimulator Hadamard Gate (1 qubit) Design the single Hadamard gate quantum circuit n = 1 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style) Manual approach: Initial state: |0> After Hadamard Gate: \\(\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>\\) Algebra: $$ H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}; |1 > = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} ; |0> = \\begin{bmatrix} 0\\\\ 1 \\end{bmatrix}$$ Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' ) Unitary representation n = 1 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.70710678+0.j 0.70710678+0.j] [ 0.70710678+0.j -0.70710678+0.j]] Hadamard Gate (2 qubits) Lets perform three different configuration of quantum circuit with two qubits and Hadamard gates. Type -I : Hadamard gate on first qubit $$I \\otimes H = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 & 0 & 0\\\\ 1 & -1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & -1 \\end{bmatrix} $$ Design circuit with two qubit with Hadamard on first qubit and perform the measurement. n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style) Unitary representation n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.70710678+0.j 0.70710678+0.j 0. +0.j 0. +0.j] [ 0.70710678+0.j -0.70710678+0.j 0. +0.j 0. +0.j] [ 0. +0.j 0. +0.j 0.70710678+0.j 0.70710678+0.j] [ 0. +0.j 0. +0.j 0.70710678+0.j -0.70710678+0.j]] Type -II : Hadamart on second qubit $$ H \\otimes I = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0 \\\\ 0 & 1 & 0 & -1 \\end{bmatrix} $$ Design a quantum circuit with two qubits and Hadamard gate on first qubit. Perform the measurement. n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 1 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style) Unitary representation n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 1 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.70710678+0.j 0. +0.j 0.70710678+0.j 0. +0.j] [ 0. +0.j 0.70710678+0.j 0. +0.j 0.70710678+0.j] [ 0.70710678+0.j 0. +0.j -0.70710678+0.j 0. +0.j] [ 0. +0.j 0.70710678+0.j 0. +0.j -0.70710678+0.j]] Type -III : Hadamard gate on both qubits $$ H_1 \\otimes H_1 = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix}$$ Design the quantum circuit with two Hadamard gates and perform measurement. n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style) Manual approach Initial state: |00> After Hadamard Gate: \\(\\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|10>\\) After Hadamard Gate: \\(\\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11>\\) This is tensor product of two Hadamard transform: \\(H|0>_A \\otimes H|0>_B\\) i.e., \\((\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\otimes (\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) = \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11> \\) Tensor Algebra: H operator in product space, \\(H_2 = H_1 \\otimes H_1\\) : $$\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix}$$ Basis States in product space, \\(|q_1q_2> = q_1 \\otimes q_2\\) : $$|00> = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0 \\end{bmatrix} ; |01> = \\begin{bmatrix} 0\\\\ 1\\\\ 0\\\\ 0 \\end{bmatrix} ; |10> = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1\\\\ 0 \\end{bmatrix} ; |11> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 1 \\end{bmatrix}$$ Linear transformation in product space: Above transformation can be represented as : $$H_2|00> = \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11>$$ With above basis vector, a state \\( \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11>\\) can be expressed as: $$\\begin{bmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ \\frac{1}{2}\\\\ \\frac{1}{2} \\end{bmatrix}$$ Thus in Matrix Form: $$ H_2|00> = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix}\\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ \\frac{1}{2}\\\\ \\frac{1}{2} \\end{bmatrix}$$ $$= \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11> $$ Tensor product of linear map: The tensor product also operates on linear maps between vector spaces. Specifically, given two linear maps \\(\ud835\udc46:\ud835\udc49\u2192\ud835\udc4b\\) and \\(\ud835\udc47:\ud835\udc4a\u2192\ud835\udc4c\\) between vector spaces, the tensor product of the two linear maps \ud835\udc46 and \ud835\udc47 is a linear map \\((\ud835\udc46 \\otimes \ud835\udc47)(v \\otimes w) = \ud835\udc46(v) \\otimes \ud835\udc47(w) \\). Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' ) Unitary representation n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j] [ 0.5+0.j -0.5+0.j 0.5+0.j -0.5+0.j] [ 0.5+0.j 0.5+0.j -0.5+0.j -0.5+0.j] [ 0.5+0.j -0.5+0.j -0.5+0.j 0.5+0.j]] Hadamard Gate (3 qubits) Desigh the quantum circuit and perform measurement n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) circ . h(q[ 2 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style) Manual approach Initial state: |000> After Hadamard gate on first qubit: \\( \\frac{1}{\\sqrt{2}}|000> + \\frac{1}{\\sqrt{2}}|100> \\) After Hadamard gate on second qubit: \\(\\frac{1}{{2}}|000> + \\frac{1}{{2}}|010> + \\frac{1}{{2}}|100> + \\frac{1}{{2}}|110>\\) After Hadamard gate on third qubit: \\( \\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |100> + |101> + |110> + |111>) \\) which is equivalent to \\((\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\otimes (\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\otimes (\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\) Tensor Algebra: H operator in product space: \\( H_3 = H_1 \\otimes H_1 \\otimes H_1 = H_2 \\otimes H_1\\): $$ \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}$$ $$ = \\frac{1}{2\\sqrt{2}} \\begin{bmatrix} 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 \\\\ 1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\ 1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 \\\\ 1 & 1 & -1 & -1 & -1 & -1 & 1 & 1 \\\\ 1 & -1 & -1 & 1 & -1 & 1 & 1 & -1 \\\\ \\end{bmatrix}$$ Basis states in product space: \\( |q_1q_2q_3> = q_1 \\otimes q_2 \\otimes q_3\\) : $$ |000> = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ \\end{bmatrix} ; |001> = \\begin{bmatrix} 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}; |010> = \\begin{bmatrix} 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}; |011> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}; |100> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}$$ $$ |101> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0 \\end{bmatrix}; |110> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0 \\end{bmatrix}; |111> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1 \\end{bmatrix}$$ Above transformation can be represented as : \\( H_3|000> = \\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |100> + |101> + |110> +|111>)\\). With above basis vector this quantum state can be expressed as: $$\\begin{bmatrix} \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\end{bmatrix}$$ Thus in Matrix Form: $$ H_3|000> = \\frac{1}{2\\sqrt{2}} \\begin{bmatrix} 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 \\\\ 1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\ 1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 \\\\ 1 & 1 & -1 & -1 & -1 & -1 & 1 & 1 \\\\ 1 & -1 & -1 & 1 & -1 & 1 & 1 & -1 \\\\ \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\end{bmatrix} $$ $$ = \\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |100> + |101> + |110> +|111>)$$ Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' ) Unitary representation n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) circ . h(q[ 2 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j] [ 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j]] Hadamard (8 Qubits) Quantum Circuit n = 8 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) for k in range ( 8 ): circ . h(q[k]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightpink' } circ . draw(output = 'mpl' , style = style) Simulation simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' ) Unitary representation n = 8 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) for k in range ( 8 ): circ . h(q[k]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.0625+0.j 0.0625+0.j 0.0625+0.j ... 0.0625+0.j 0.0625+0.j 0.0625+0.j] [ 0.0625+0.j -0.0625+0.j 0.0625+0.j ... -0.0625+0.j 0.0625+0.j -0.0625+0.j] [ 0.0625+0.j 0.0625+0.j -0.0625+0.j ... 0.0625+0.j -0.0625+0.j -0.0625+0.j] ... [ 0.0625+0.j -0.0625+0.j 0.0625+0.j ... -0.0625+0.j 0.0625+0.j -0.0625+0.j] [ 0.0625+0.j 0.0625+0.j -0.0625+0.j ... 0.0625+0.j -0.0625+0.j -0.0625+0.j] [ 0.0625+0.j -0.0625+0.j -0.0625+0.j ... -0.0625+0.j -0.0625+0.j 0.0625+0.j]] unitary . shape (256, 256) The End Reference: https://quantumcomputing.stackexchange.com/questions/2270/how-to-input-2-qubits-in-2-hadamard-gates","title":"Superposition"},{"location":"circuits/hadamard/hadamard/#hadamard-gate-and-circuits","text":"Hadamard gate is single qubit operator. This transforms |0> state to a superposed state \\(\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>\\) and stae|1> to a superposed state \\(\\frac{1}{\\sqrt{2}}|0> - \\frac{1}{\\sqrt{2}}|1>\\). This gate is very important gate to construct Bell state, Quantum Fourier Transform (QFT) and many more. Import python library to perform computation in 'Qiskit' environment. % matplotlib inline # Importing standard Qiskit libraries and configuring account from qiskit import QuantumCircuit, QuantumRegister,ClassicalRegister from qiskit import execute, Aer, IBMQ from qiskit.compiler import transpile, assemble from qiskit.tools.jupyter import * from qiskit.visualization import * from qiskit.providers.aer import UnitarySimulator","title":"Hadamard Gate and Circuits"},{"location":"circuits/hadamard/hadamard/#hadamard-gate-1-qubit","text":"Design the single Hadamard gate quantum circuit n = 1 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style)","title":"Hadamard Gate (1 qubit)"},{"location":"circuits/hadamard/hadamard/#manual-approach","text":"Initial state: |0> After Hadamard Gate: \\(\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>\\)","title":"Manual approach:"},{"location":"circuits/hadamard/hadamard/#algebra","text":"$$ H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}; |1 > = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} ; |0> = \\begin{bmatrix} 0\\\\ 1 \\end{bmatrix}$$","title":"Algebra:"},{"location":"circuits/hadamard/hadamard/#simulation","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' )","title":"Simulation"},{"location":"circuits/hadamard/hadamard/#unitary-representation","text":"n = 1 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.70710678+0.j 0.70710678+0.j] [ 0.70710678+0.j -0.70710678+0.j]]","title":"Unitary representation"},{"location":"circuits/hadamard/hadamard/#hadamard-gate-2-qubits","text":"Lets perform three different configuration of quantum circuit with two qubits and Hadamard gates.","title":"Hadamard Gate (2 qubits)"},{"location":"circuits/hadamard/hadamard/#type-i-hadamard-gate-on-first-qubit","text":"$$I \\otimes H = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 & 0 & 0\\\\ 1 & -1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & -1 \\end{bmatrix} $$ Design circuit with two qubit with Hadamard on first qubit and perform the measurement. n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style)","title":"Type -I : Hadamard gate on first qubit"},{"location":"circuits/hadamard/hadamard/#unitary-representation_1","text":"n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.70710678+0.j 0.70710678+0.j 0. +0.j 0. +0.j] [ 0.70710678+0.j -0.70710678+0.j 0. +0.j 0. +0.j] [ 0. +0.j 0. +0.j 0.70710678+0.j 0.70710678+0.j] [ 0. +0.j 0. +0.j 0.70710678+0.j -0.70710678+0.j]]","title":"Unitary representation"},{"location":"circuits/hadamard/hadamard/#type-ii-hadamart-on-second-qubit","text":"$$ H \\otimes I = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 0 & 1 & 0\\\\ 0 & 1 & 0 & 1\\\\ 1 & 0 & -1 & 0 \\\\ 0 & 1 & 0 & -1 \\end{bmatrix} $$ Design a quantum circuit with two qubits and Hadamard gate on first qubit. Perform the measurement. n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 1 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style)","title":"Type -II : Hadamart on second qubit"},{"location":"circuits/hadamard/hadamard/#unitary-representation_2","text":"n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 1 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.70710678+0.j 0. +0.j 0.70710678+0.j 0. +0.j] [ 0. +0.j 0.70710678+0.j 0. +0.j 0.70710678+0.j] [ 0.70710678+0.j 0. +0.j -0.70710678+0.j 0. +0.j] [ 0. +0.j 0.70710678+0.j 0. +0.j -0.70710678+0.j]]","title":"Unitary representation"},{"location":"circuits/hadamard/hadamard/#type-iii-hadamard-gate-on-both-qubits","text":"$$ H_1 \\otimes H_1 = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix}$$ Design the quantum circuit with two Hadamard gates and perform measurement. n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style)","title":"Type -III : Hadamard gate on both qubits"},{"location":"circuits/hadamard/hadamard/#manual-approach_1","text":"Initial state: |00> After Hadamard Gate: \\(\\frac{1}{\\sqrt{2}}|00> + \\frac{1}{\\sqrt{2}}|10>\\) After Hadamard Gate: \\(\\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11>\\) This is tensor product of two Hadamard transform: \\(H|0>_A \\otimes H|0>_B\\) i.e., \\((\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\otimes (\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) = \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11> \\)","title":"Manual approach"},{"location":"circuits/hadamard/hadamard/#tensor-algebra","text":"H operator in product space, \\(H_2 = H_1 \\otimes H_1\\) : $$\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix}$$ Basis States in product space, \\(|q_1q_2> = q_1 \\otimes q_2\\) : $$|00> = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0 \\end{bmatrix} ; |01> = \\begin{bmatrix} 0\\\\ 1\\\\ 0\\\\ 0 \\end{bmatrix} ; |10> = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1\\\\ 0 \\end{bmatrix} ; |11> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 1 \\end{bmatrix}$$ Linear transformation in product space: Above transformation can be represented as : $$H_2|00> = \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11>$$ With above basis vector, a state \\( \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11>\\) can be expressed as: $$\\begin{bmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ \\frac{1}{2}\\\\ \\frac{1}{2} \\end{bmatrix}$$ Thus in Matrix Form: $$ H_2|00> = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix}\\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\\\ \\frac{1}{2}\\\\ \\frac{1}{2} \\end{bmatrix}$$ $$= \\frac{1}{{2}}|00> + \\frac{1}{{2}}|01> + \\frac{1}{{2}}|10> + \\frac{1}{{2}}|11> $$","title":"Tensor Algebra:"},{"location":"circuits/hadamard/hadamard/#tensor-product-of-linear-map","text":"The tensor product also operates on linear maps between vector spaces. Specifically, given two linear maps \\(\ud835\udc46:\ud835\udc49\u2192\ud835\udc4b\\) and \\(\ud835\udc47:\ud835\udc4a\u2192\ud835\udc4c\\) between vector spaces, the tensor product of the two linear maps \ud835\udc46 and \ud835\udc47 is a linear map \\((\ud835\udc46 \\otimes \ud835\udc47)(v \\otimes w) = \ud835\udc46(v) \\otimes \ud835\udc47(w) \\).","title":"Tensor product of linear map:"},{"location":"circuits/hadamard/hadamard/#simulation_1","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' )","title":"Simulation"},{"location":"circuits/hadamard/hadamard/#unitary-representation_3","text":"n = 2 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.5+0.j 0.5+0.j 0.5+0.j 0.5+0.j] [ 0.5+0.j -0.5+0.j 0.5+0.j -0.5+0.j] [ 0.5+0.j 0.5+0.j -0.5+0.j -0.5+0.j] [ 0.5+0.j -0.5+0.j -0.5+0.j 0.5+0.j]]","title":"Unitary representation"},{"location":"circuits/hadamard/hadamard/#hadamard-gate-3-qubits","text":"Desigh the quantum circuit and perform measurement n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) circ . h(q[ 2 ]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightgreen' } circ . draw(output = 'mpl' , style = style)","title":"Hadamard Gate (3 qubits)"},{"location":"circuits/hadamard/hadamard/#manual-approach_2","text":"Initial state: |000> After Hadamard gate on first qubit: \\( \\frac{1}{\\sqrt{2}}|000> + \\frac{1}{\\sqrt{2}}|100> \\) After Hadamard gate on second qubit: \\(\\frac{1}{{2}}|000> + \\frac{1}{{2}}|010> + \\frac{1}{{2}}|100> + \\frac{1}{{2}}|110>\\) After Hadamard gate on third qubit: \\( \\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |100> + |101> + |110> + |111>) \\) which is equivalent to \\((\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\otimes (\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\otimes (\\frac{1}{\\sqrt{2}}|0> + \\frac{1}{\\sqrt{2}}|1>) \\)","title":"Manual approach"},{"location":"circuits/hadamard/hadamard/#tensor-algebra_1","text":"H operator in product space: \\( H_3 = H_1 \\otimes H_1 \\otimes H_1 = H_2 \\otimes H_1\\): $$ \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \\\\ \\end{bmatrix} \\otimes \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}$$ $$ = \\frac{1}{2\\sqrt{2}} \\begin{bmatrix} 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 \\\\ 1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\ 1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 \\\\ 1 & 1 & -1 & -1 & -1 & -1 & 1 & 1 \\\\ 1 & -1 & -1 & 1 & -1 & 1 & 1 & -1 \\\\ \\end{bmatrix}$$ Basis states in product space: \\( |q_1q_2q_3> = q_1 \\otimes q_2 \\otimes q_3\\) : $$ |000> = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ \\end{bmatrix} ; |001> = \\begin{bmatrix} 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}; |010> = \\begin{bmatrix} 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}; |011> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}; |100> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}$$ $$ |101> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0\\\\ 0 \\end{bmatrix}; |110> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1\\\\ 0 \\end{bmatrix}; |111> = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 1 \\end{bmatrix}$$ Above transformation can be represented as : \\( H_3|000> = \\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |100> + |101> + |110> +|111>)\\). With above basis vector this quantum state can be expressed as: $$\\begin{bmatrix} \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\end{bmatrix}$$ Thus in Matrix Form: $$ H_3|000> = \\frac{1}{2\\sqrt{2}} \\begin{bmatrix} 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 \\\\ 1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\ 1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 \\\\ 1 & 1 & -1 & -1 & -1 & -1 & 1 & 1 \\\\ 1 & -1 & -1 & 1 & -1 & 1 & 1 & -1 \\\\ \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}} \\\\ \\frac{1}{2\\sqrt{2}}\\\\ \\frac{1}{2\\sqrt{2}} \\end{bmatrix} $$ $$ = \\frac{1}{2\\sqrt{2}}(|000> + |001> + |010> + |011> + |100> + |101> + |110> +|111>)$$","title":"Tensor Algebra:"},{"location":"circuits/hadamard/hadamard/#simulation_2","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' )","title":"Simulation"},{"location":"circuits/hadamard/hadamard/#unitary-representation_4","text":"n = 3 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) circ . h(q[ 0 ]) circ . h(q[ 1 ]) circ . h(q[ 2 ]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j] [ 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j] [ 0.35355339+0.j -0.35355339+0.j -0.35355339+0.j 0.35355339+0.j -0.35355339+0.j 0.35355339+0.j 0.35355339+0.j -0.35355339+0.j]]","title":"Unitary representation"},{"location":"circuits/hadamard/hadamard/#hadamard-8-qubits","text":"","title":"Hadamard (8 Qubits)"},{"location":"circuits/hadamard/hadamard/#quantum-circuit","text":"n = 8 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) for k in range ( 8 ): circ . h(q[k]) circ . measure(q,c) # Change the background color in mpl style = { 'backgroundcolor' : 'lightpink' } circ . draw(output = 'mpl' , style = style)","title":"Quantum Circuit"},{"location":"circuits/hadamard/hadamard/#simulation_3","text":"simulator = Aer . get_backend( 'qasm_simulator' ) result = execute(circ, simulator) . result() counts = result . get_counts(circ) plot_histogram(counts, title = 'Bell-State counts' )","title":"Simulation"},{"location":"circuits/hadamard/hadamard/#unitary-representation_5","text":"n = 8 q = QuantumRegister(n) c = ClassicalRegister(n) circ = QuantumCircuit(q,c) for k in range ( 8 ): circ . h(q[k]) # Select the UnitarySimulator from the Aer provider simulator = Aer . get_backend( 'unitary_simulator' ) # Execute and get counts result = execute(circ, simulator) . result() unitary = result . get_unitary(circ) print ( unitary) [[ 0.0625+0.j 0.0625+0.j 0.0625+0.j ... 0.0625+0.j 0.0625+0.j 0.0625+0.j] [ 0.0625+0.j -0.0625+0.j 0.0625+0.j ... -0.0625+0.j 0.0625+0.j -0.0625+0.j] [ 0.0625+0.j 0.0625+0.j -0.0625+0.j ... 0.0625+0.j -0.0625+0.j -0.0625+0.j] ... [ 0.0625+0.j -0.0625+0.j 0.0625+0.j ... -0.0625+0.j 0.0625+0.j -0.0625+0.j] [ 0.0625+0.j 0.0625+0.j -0.0625+0.j ... 0.0625+0.j -0.0625+0.j -0.0625+0.j] [ 0.0625+0.j -0.0625+0.j -0.0625+0.j ... -0.0625+0.j -0.0625+0.j 0.0625+0.j]] unitary . shape (256, 256) The End","title":"Unitary representation"},{"location":"circuits/hadamard/hadamard/#reference","text":"https://quantumcomputing.stackexchange.com/questions/2270/how-to-input-2-qubits-in-2-hadamard-gates","title":"Reference:"},{"location":"gates/mgates/mgates/","text":"Coming Soon Under construction","title":"Multiple Qubits Gates"},{"location":"gates/mgates/mgates/#coming-soon","text":"Under construction","title":"Coming Soon"},{"location":"gates/sgates/sgates/","text":"Coming Soon Under construction","title":"Single Qubit Gates"},{"location":"gates/sgates/sgates/#coming-soon","text":"Under construction","title":"Coming Soon"},{"location":"optimization/dwave/","text":"Quantum Computing with D-Wave Quantum Computer Introduction source Quantum computing has the potential to help solve some of the most complex technical, scientific, national defense, and commercial problems that organizations face. For quantum computing, as for classical, the first step in solving a problem is to express it in a mathematical formulation compatible with the underlying physical hardware. D-Wave systems solve problems that can be mapped onto an Ising model or a quadratic unconstrained binary optimization (QUBO) problem . is an objective function of N binary variables represented as an upper-diagonal matrix Q, where diagonal terms are the linear coefficients and the nonzero off-diagonal terms the quadratic coefficients. The mapped problem must be formulated to be compatible with the constraints of the physical system and as robust as possible to analog control errors. Example from constraint satisfaction problem (CSP) This example solves a map coloring problem to demonstrate an out-of-the-box use of Ocean\u2019s classical-quantum hybrid sampler, dwave-hybrid Kerberos , that enables you to solve problems of arbitrary structure and size. Map coloring is an example of a constraint satisfaction problem (CSP) . CSPs require that all a problem\u2019s variables be assigned values, out of a finite domain, that result in the satisfying of all constraints. The map-coloring CSP is to assign a color to each region of a map such that any two regions sharing a border have different colors. The Map Coloring advanced example demonstrates lower-level coding of a similar problem, which gives the user more control over the solution procedure but requires the knowledge of some system parameters (e.g., knowing the maximum number of supported variables for the problem). Example Problem With Many Variables demonstrates the hybrid approach to problem solving in more detail by explicitly configuring the classical and quantum workflows. import networkx as nx G = nx . read_adjlist( 'usa.adj' , delimiter = ',' ) Quantum Implementation Solution Steps Section Solving Problems on a D-Wave System describes the process of solving problems on the quantum computer in two steps: - (1) Formulate the problem as a binary quadratic model (BQM) and - (2) Solve the BQM with a D-wave system or classical sampler. In this example, a function in Ocean software handles both steps. Our task is mainly to select the sampler used to solve the problem. For graph G(V,E) of the map problem\u2014no two vertices, V, connected by an edge, E, should select the same color from set C\u2014construct a cost function with binary variables, $x_{v,c}=1$ when $v\u2208V$ selects color $c\u2208C$, by implementing two constraints: $$(\\sum_c x_{v,c} -1)^2$$ which has minimum energy (zero) when vertices select one color only, and $$\\sum_c \\sum_{v_a,v_b \\in E} x_{v_a,c} x_{v_b,c},$$ which adds a penalty if the vertices of an edge select the same color. $$E(x_v,x_{v_a,v_b}) = \\sum_v (\\sum_c x_{v,c} -1)^2 + \\sum_c \\sum_{v_a,v_b \\in E} x_{v_a,c} x_{v_b,c}.$$ The minima (ground states) of this QUBO have zero energy for viable solutions. This formulation of the generic problem must still be applied to the map and color set and then embedded. This section solved the map-coloring problem using a technique of formulating a problem as a constraint satisfaction problem (CSP) using penalty functions. The CSP Reformulation with Penalty Functions section describes this technique and demonstrates it in detail on a simple two-color, two-region part of this map-coloring problem in the Example of CSP reformulation with penalty functions section. import dwave_networkx as dnx from hybrid.reference.kerberos import KerberosSampler Prepare coloring scheme using D-Wave kerberoSamplers coloring = dnx . min_vertex_coloring(G, sampler = KerberosSampler(),\\ chromatic_ub = 4 ,\\ max_iter = 10 ,\\ convergence = 3 ) set (coloring . values()) {0, 1, 2, 3} import matplotlib.pyplot as plt plt . figure(figsize = [ 12 , 10 ]) node_colors = [coloring . get(node) for node in G . nodes()] # adjust the next line if using a different map if dnx . is_vertex_coloring(G, coloring): nx . draw(G, pos = nx . shell_layout(G, nlist = [ list (G . nodes)[x:x + 10 ] \\ for x in range ( 0 , 50 , 10 )] + [[ list (G . nodes)[ 50 ]]]),\\ with_labels = True , \\ node_color = node_colors,\\ node_size = 400 ,\\ cmap = plt . cm . rainbow) plt . show()","title":"Binary Quadratic Model (BQM)"},{"location":"optimization/dwave/#quantum-computing-with-d-wave-quantum-computer","text":"","title":"Quantum Computing with D-Wave Quantum Computer"},{"location":"optimization/dwave/#introduction-source","text":"Quantum computing has the potential to help solve some of the most complex technical, scientific, national defense, and commercial problems that organizations face. For quantum computing, as for classical, the first step in solving a problem is to express it in a mathematical formulation compatible with the underlying physical hardware. D-Wave systems solve problems that can be mapped onto an Ising model or a quadratic unconstrained binary optimization (QUBO) problem . is an objective function of N binary variables represented as an upper-diagonal matrix Q, where diagonal terms are the linear coefficients and the nonzero off-diagonal terms the quadratic coefficients. The mapped problem must be formulated to be compatible with the constraints of the physical system and as robust as possible to analog control errors.","title":"Introduction source"},{"location":"optimization/dwave/#example-from-constraint-satisfaction-problem-csp","text":"This example solves a map coloring problem to demonstrate an out-of-the-box use of Ocean\u2019s classical-quantum hybrid sampler, dwave-hybrid Kerberos , that enables you to solve problems of arbitrary structure and size. Map coloring is an example of a constraint satisfaction problem (CSP) . CSPs require that all a problem\u2019s variables be assigned values, out of a finite domain, that result in the satisfying of all constraints. The map-coloring CSP is to assign a color to each region of a map such that any two regions sharing a border have different colors. The Map Coloring advanced example demonstrates lower-level coding of a similar problem, which gives the user more control over the solution procedure but requires the knowledge of some system parameters (e.g., knowing the maximum number of supported variables for the problem). Example Problem With Many Variables demonstrates the hybrid approach to problem solving in more detail by explicitly configuring the classical and quantum workflows. import networkx as nx G = nx . read_adjlist( 'usa.adj' , delimiter = ',' )","title":"Example from constraint satisfaction problem (CSP)"},{"location":"optimization/dwave/#quantum-implementation","text":"","title":"Quantum Implementation"},{"location":"optimization/dwave/#solution-steps","text":"Section Solving Problems on a D-Wave System describes the process of solving problems on the quantum computer in two steps: - (1) Formulate the problem as a binary quadratic model (BQM) and - (2) Solve the BQM with a D-wave system or classical sampler. In this example, a function in Ocean software handles both steps. Our task is mainly to select the sampler used to solve the problem. For graph G(V,E) of the map problem\u2014no two vertices, V, connected by an edge, E, should select the same color from set C\u2014construct a cost function with binary variables, $x_{v,c}=1$ when $v\u2208V$ selects color $c\u2208C$, by implementing two constraints: $$(\\sum_c x_{v,c} -1)^2$$ which has minimum energy (zero) when vertices select one color only, and $$\\sum_c \\sum_{v_a,v_b \\in E} x_{v_a,c} x_{v_b,c},$$ which adds a penalty if the vertices of an edge select the same color. $$E(x_v,x_{v_a,v_b}) = \\sum_v (\\sum_c x_{v,c} -1)^2 + \\sum_c \\sum_{v_a,v_b \\in E} x_{v_a,c} x_{v_b,c}.$$ The minima (ground states) of this QUBO have zero energy for viable solutions. This formulation of the generic problem must still be applied to the map and color set and then embedded. This section solved the map-coloring problem using a technique of formulating a problem as a constraint satisfaction problem (CSP) using penalty functions. The CSP Reformulation with Penalty Functions section describes this technique and demonstrates it in detail on a simple two-color, two-region part of this map-coloring problem in the Example of CSP reformulation with penalty functions section. import dwave_networkx as dnx from hybrid.reference.kerberos import KerberosSampler Prepare coloring scheme using D-Wave kerberoSamplers coloring = dnx . min_vertex_coloring(G, sampler = KerberosSampler(),\\ chromatic_ub = 4 ,\\ max_iter = 10 ,\\ convergence = 3 ) set (coloring . values()) {0, 1, 2, 3} import matplotlib.pyplot as plt plt . figure(figsize = [ 12 , 10 ]) node_colors = [coloring . get(node) for node in G . nodes()] # adjust the next line if using a different map if dnx . is_vertex_coloring(G, coloring): nx . draw(G, pos = nx . shell_layout(G, nlist = [ list (G . nodes)[x:x + 10 ] \\ for x in range ( 0 , 50 , 10 )] + [[ list (G . nodes)[ 50 ]]]),\\ with_labels = True , \\ node_color = node_colors,\\ node_size = 400 ,\\ cmap = plt . cm . rainbow) plt . show()","title":"Solution Steps"}]}